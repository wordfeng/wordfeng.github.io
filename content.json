{"meta":{"title":"while(live){coding}","subtitle":"一个有味道的博客","description":"描述","author":"慕华","url":"https://blog.ojbkfeng.com"},"pages":[{"title":"","date":"2019-02-24T15:11:13.887Z","updated":"2019-01-14T08:00:42.528Z","comments":true,"path":"404.html","permalink":"https://blog.ojbkfeng.com/404.html","excerpt":"","text":"404 not found 你要找的页面不翼而飞了！"},{"title":"categories","date":"2019-01-17T05:47:48.000Z","updated":"2019-01-17T05:48:06.265Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ojbkfeng.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-24T15:11:13.898Z","updated":"2019-01-17T05:46:26.450Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ojbkfeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"流式操作，让操作集合跟Python一样简单","slug":"JAVA/基础/stream","date":"2019-05-01T04:23:51.188Z","updated":"2019-05-03T02:16:22.552Z","comments":true,"path":"2019/05/01/JAVA/基础/stream/","link":"","permalink":"https://blog.ojbkfeng.com/2019/05/01/JAVA/基础/stream/","excerpt":"","text":"1. 什么是流流是从支持数据处理操作的源生的一系列元素。流利用内部迭代，中间操作会返回一个流并且可以链接在一起，可以用来设置一条流水线不生成任何结果。流中的元素的按需计算的，类似于Python中的生成器，都是惰性计算，需要的时候产生结果。个人认为有了流，操作起数据来方便程度跟python有得一拼。12345678910111213141516171819List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"王麻子\"); list.add(\"张三丰\"); list.add(\"狮子\"); //统计集合中有字符长度为3的元素个数 //普通写法 long count=0; //外部迭代 for (String s : list) &#123; if(s.length()==3)&#123; count++; &#125; &#125; //使用流 long count = list.stream() .filter((name) -&gt; name.length() == 3)//内部迭代 .count(); 首先第一步list.stream()支持流第二步filter()过滤字符串长度为3的元素第三部count()统计过滤后的元素个数 其中第二步称为中间操作第三步称为终端操作 2. 中间操作 操作 操作类型 返回值 使用的类型/函数式接口 函数描述符 作用 filter 中间 Stream&lt;T> Predicate&lt;T> T -&gt; boolean 过滤元素 map 中间 Stream&lt;T> Function&lt;T, R&gt; T -&gt; R 映射元素 limit 中间(有状态-有界) Stream&lt;T> long limit(n)返回前n个元素 sorted 中间(有状态-有界) Stream&lt;T> Comparetor&lt;T> (T, T) -&gt; int 排序 distinct 中间(有状态-无界) Stream&lt;T> 去重 skip 中间(有状态-有界) Stream&lt;T> long skip(n)跳过前n个元素 flatMap 中间 Stream&lt;T> Function&lt;T,Stream&lt;R>&gt; T-&gt;Stream&lt;R> 3. 终端操作 操作 操作类型 返回值 使用的类型/函数式接口 函数描述符 作用 forEach 终端 void Consumer&lt;T> T-&gt;void 消费流中的每个元素并对其应用Lambda。返回void count 终端 long 返回流中元素的个数 collect 终端 R Collector&lt;T,A,T&gt; 把流归约成一个集合，比如List，Map甚至Integer。 anyMatch 终端 boolean Predicate&lt;T> T-&gt;boolean 返回流中给匹配谓词的元素 findAny 终端 Optional 返回任意一个元素 findFirst 终端 Optional 返回第一个元素 reduce 终端(有状态-有界) Optional&lt;T> BinaryOperator (T,T)-&gt;T 归约 4. 筛选(filter)Streams接口的filter会接收一个谓词(一个返回boolean的函数)作为参数，并且包含所有符合谓词表述的元素的流。 筛选出集合中的奇数，并且去重。12345678List&lt;Integer&gt; list = Arrays.asList(1,2,3,3,4,5,6,7,8,9,10);list.stream() .filter((i)-&gt;(i &amp; 1)==1) .distinct() .forEach(System.out::println); //.collect(toList()); //直接转换成集合返回 //终端操作只能一次 5. 映射(map)例1：统计每一个字符串的长度。12345List&lt;String&gt; list = Arrays.asList(\"I\", \"am\", \"a\", \"Student\");list.stream() .map(String::length) .forEach(System.out::println); 例2：将[“I”, “am”, “a”, “Student”]变成[[“I”, “a”, m”, “a”, “S”,”t”, “u”, “d”. “e”, “n”, “t”]] 解11234List&lt;String&gt; list = Arrays.asList(\"I\", \"am\", \"a\", \"Student\");list.stream() .map((word -&gt; word.split(\"\"))) .collect(toList()); 这样子处理返回的是List&lt;String[]>类型的，是[[“I”],[“a”,”m”],[“a”],[…]], 跟预期的结果不一样。需要的是一个字符流，而不是数组流。 解2如果让每个数组都变成单独的流呢？Arrays.stream()可以做到：1234list.stream() .map((word -&gt; word.split(\"\"))) .map(Arrays::stream) //让每个数组变成单独的流 .collect(toList()); 但是这样做以后返回值会变成Stream类型的，怎么合成一个流呢？ 接下来就要用到新东西了，流的扁平化 6. 合并流(flatMap)flatMap将各个生成流扁平化为单个流 解例21234list.stream() .map((word -&gt; word.split(\"\"))) .flatMap(Arrays::stream) .forEach(System.out::println); 终于达到了想要的结果返回值为List 例3给定[1,2,3]和[1,2]求他们的笛卡尔积。123456List&lt;Integer&gt; num1 = Arrays.asList(1,2,3);List&lt;Integer&gt; num2 = Arrays.asList(3,4);List&lt;int[]&gt; collect = num1.stream() .flatMap(i -&gt; num2.stream() .map(j -&gt; new int[]&#123;i, j&#125;) ).collect(toList()); 7. 查找和匹配7.1 匹配任意一个(anyMatch)返回一个boolean，所以是一个终端操作。 123if(students.stream().anyMatch(Student::isGoodStudent))&#123; System.out.println(\"有好孩子\");&#125; 7.2 匹配所有(allMatch)终端操作，跟anyMatch差不多，只有所有都为true才为true 7.3 没有任何匹配(noneMatch)没有任何元素匹配才为true anyMatch、allMatch、noneMatch都是短路操作。 7.4 查找任意一元素(findAny)查找任意元素：可以结合filter过滤使用，会返回一个Optional[3]这样的东西，Optional类（java.util.Optional）是一个容器类，代表一个值存在或不存在。findAny可能什么都没找到，返回Optional[3]就可以不用返回null了。可以用T get()获取返回值(如果有的话，没有则返回NoSuchElem异常)。 7.5 查找第一个元素(findFirst)返回第一个元素。 8. 归约把流中的元素全部组合起来，表达一个复杂的查询结果。比如计算总数，查找最大值。 8.1 reducereduce接收两个参数,有三个重载12345678//有初始值返回TT reduce(T identity, BinaryOperator&lt;T&gt; accumulator);//无初始值，返回Optional&lt;T&gt;Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);//???&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); 这里的BinaryOperator是继承自BiFunction的函数式接口 1234//用第一个参数键入初始值，第二个参数将两个元素结合起来生成一个新值 List&lt;Integer&gt; num1 = Arrays.asList(1,2,3,4,5,6); int num = num1.stream().reduce(0,(a,b)-&gt;a+b); System.out.println(num);//21 用map和reduce统计集合中元素个数12num1.stream().map(i-&gt;1).reduce((a,b)-&gt;a+b).get() map-reduce模式容易并行化，google用这种模式做搜索。 8.2 reduce的优势使用reduce的优势在于，迭代被内部迭代抽象了，这让内部实现可以选择并行执行reduce操作。如果使用外部迭代器，要不断更新共享变量sum，不容易并行化，如果使用同步synchronize和ReentrantLock之类的锁同步，需要将输入分块，分块求和，最后再合并起来。使用reduce只需要把stream()改成parallelStream()即可。 并行流(parallelStream())并行流也可能会付出一些代价。传递给reduce的Lambda不能更改状态(比如实例变量), 而且操作必须满足结合律才可以按任意顺序执行。 有状态和无状态像map，reduce之类的操作会从输入流中获取每一个元素，并且在输出流中得到0/1个结果，这种操作叫无状态。 像reduce，sum，max操作需要内部状态积累结果，但是内部状态很小，不过内部状态是有界的。 像sort，distinct需要把元素都放入缓冲区后才能在输出流加入元素，如果流很大，或者是无限的就会有问题。 数值流可以将流转换为数值，减少自动装箱、拆箱的消耗。例：求需要发的员工工资总和。每个Integer都要拆箱成一个int原始类型求和。123int totalSalary = empl.stream() .map(Emploee::getSalary) .reduce(0,Integer::sum); java8用了三个原始类型特化流接口解决：IntStream、DoubleStream、LongStream，将对象流特化为对应的原始类型(数值流)。 映射到数值流流转换方法：mapToInt、mapToDouble、mapToLong，跟原始的map工作方式一样，只不过返回的是特化流而不是Stream&lt;T>。 123int totalSalary = empl.stream() .mapToInt(Emploee::getSalary) //mapToInt返回值是IntStream,不是Stream&lt;Integer&gt; .sum(); 转换回对象流只需要使用boxed()装箱就行了。 123int totalSalary = empl.stream() .map(Emploee::getSalary);Stream&lt;Integer&gt; s = totalSalary.boxed(); 扩展阅读Java 8新特性（二）：Stream API","categories":[{"name":"java","slug":"java","permalink":"https://blog.ojbkfeng.com/categories/java/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://blog.ojbkfeng.com/tags/函数式编程/"}]},{"title":"反射(reflect)","slug":"JAVA/基础/反射","date":"2019-04-30T23:36:15.978Z","updated":"2019-05-01T02:09:10.804Z","comments":true,"path":"2019/05/01/JAVA/基础/反射/","link":"","permalink":"https://blog.ojbkfeng.com/2019/05/01/JAVA/基础/反射/","excerpt":"","text":"反射反射的好处：在程序运行过程中操作对象可以提高程序的扩展性，解耦 获取Class对象的时机方式：1. .class文件未加载阶段在未加载阶段，将字节码文件加载进内存，返回Class对象：Class.forName(“包名+类名”) 多用于配置文件，将类名定义在配置文件中，读取文件，加载类123Class&lt;?&gt; clas1 = Class.forName(\"com.learn.reflect.Scholar\");System.out.println(clas1);//class com.learn.reflect.Scholar 2. Class类对象阶段(对象已经被ClassLoader加载入内存)，通过类名的属性：类名.class 多用于参数的传递123Class&lt;Scholar&gt; clas2 = Scholar.class;System.out.println(clas2);//class com.learn.reflect.Scholar 3. 在程序Runtime阶段，使用Object类的方法：对象.getClass() 多用于对象获取字节码的方式1234Scholar scholar1 = new Scholar();Class&lt;? extends Scholar&gt; clas3 = scholar1.getClass();System.out.println(clas3);//class com.learn.reflect.Scholar 比较三种方式内存地址的比较123System.out.println(clas1 == clas2);//trueSystem.out.println(clas2 == clas3);//trueSystem.out.println(clas1 == clas3);//true 结论：不管用哪种方式获取的class对象是同一个，区别仅仅是获取的时机不同。 Class对象的操作1.获取成员变量 Field[] getFields() 获取public修饰的成员变量 Field getField(String name) 获取指定名字的public修饰的成员变量 Field[] getDeclaredFields() 获取所有定义了的成员变量 Field getDeclaredFields(String name) 获取构造方法 Constructor&lt;?&gt; [] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt; [] getDeclaredConstructors() Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 获取成员方法 Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取类名 String getName() 获取后的操作set() get()方法1234567Scholar scholar = new Scholar();Field fields = clas1.getDeclaredField(\"name\");//忽略权限修饰符的检查，将私有变量设置为可访问，暴力反射fields.setAccessible(true);System.out.println(fields.get(scholar));//nullfields.set(scholar,\"王麻子\");System.out.println(fields.get(scholar)); 类&lt;?&gt;… parameterTypes的含义12345Class&lt;Scholar&gt; clas2 = Scholar.class;Constructor&lt;Scholar&gt; constructor = clas2.getConstructor(int.class, String.class);Scholar obj = constructor.newInstance(40, \"老妈子\");System.out.println(obj); getMehod如何执行如果使用getMethods 返回的方法包含了Object的方法，因为所有类都是Object的子类直接引用上一个代码块的Scholar对象obj123Method setAge = clas2.getMethod(\"setAge\",int.class);setAge.invoke(obj,50);System.out.println(obj); 配置文件作为中间数据，加载执行其他类对象、方法12345678910111213Properties properties = new Properties(); //获取、加载配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream in = classLoader.getResourceAsStream(\"config.propertites\"); properties.load(in); //获取配置文件中定义的数据 String className = properties.getProperty(\"className\"); String methodName = properties.getProperty(\"methodName\"); //将目标类加载进内存 Class clas = Class.forName(className); Object obj = clas.newInstance(); Method method = clas.getMethod(methodName); method.invoke(obj);","categories":[{"name":"java","slug":"java","permalink":"https://blog.ojbkfeng.com/categories/java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://blog.ojbkfeng.com/tags/反射/"}]},{"title":"socket实现web服务器端","slug":"后端开发/网络编程/serverHello","date":"2019-04-30T06:51:03.898Z","updated":"2019-04-30T15:17:36.925Z","comments":true,"path":"2019/04/30/后端开发/网络编程/serverHello/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/30/后端开发/网络编程/serverHello/","excerpt":"","text":"http://127.0.0.1:8000/webserver/web/index.html 项目名：webserver资源名目录： /web 返回hello12345678910111213141516171819202122232425262728package web.server;import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); //获取客户端的socket Socket accept = server.accept(); InputStream clientIS = accept.getInputStream(); clientIS.read();//必须得对客户端socket任意操作一波，不然没办法返回内容 OutputStream outputStream = accept.getOutputStream(); outputStream.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); outputStream.write(\"Content-Type:text/html\\r\\n\".getBytes()); //写入空行，否则浏览器不解析 outputStream.write(\"\\r\\n\".getBytes()); outputStream.write(\"hello\".getBytes()); accept.close(); server.close(); &#125;&#125; 返回html浏览器解析服务器回写的html页面中，如果有图片，那么浏览器会单独开一个线程，读取服务器的图片 所以必须使服务无线循环 不能单次服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package file.upload;import java.io.*;import java.net.ServerSocket;import java.net.Socket;//serverpublic class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); while(true)&#123; Socket accept = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; InputStream inputStream = accept.getInputStream(); //判断upload文件夹是否存在 File file = new File(\"D:\\\\upload\"); if(!file.exists())&#123; file.mkdirs(); &#125; FileOutputStream fileOutputStream = new FileOutputStream(file +\"\\\\\"+System.currentTimeMillis()+\".gif\"); int len = 0; byte[] bytes = new byte[1024 * 10]; while ((len = inputStream.read(bytes)) != -1) &#123; //写入本地 fileOutputStream.write(bytes, 0, len); &#125; accept.getOutputStream().write(\"接收完毕\".getBytes()); fileOutputStream.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; accept.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125;// server.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ojbkfeng.com/categories/Java/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://blog.ojbkfeng.com/tags/网络编程/"}]},{"title":"TCP实现简单图片文件上传服务器","slug":"后端开发/网络编程/Socket","date":"2019-04-29T04:21:51.944Z","updated":"2019-05-04T13:08:22.153Z","comments":true,"path":"2019/04/29/后端开发/网络编程/Socket/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/29/后端开发/网络编程/Socket/","excerpt":"","text":"客户端 java.net.Socket服务端 java.net.ServerSocket 客户端和服务端直接是逻辑连接，其中包含一个IO对象(字节流对象), 服务端用客户端的流跟客户端交互。 serversocket.accept()获取客户端的Socket请求对象 Server端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package file.upload;import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); //获取客户端socket对象 while(true)&#123; //获取客户端Socket对象 Socket accept = server.accept(); //网络字节输入流获取客户端数据 new Thread(new Runnable() &#123; //一个客户端连接，建立一个线程 @Override public void run() &#123; try&#123; InputStream inputStream = accept.getInputStream(); //判断upload文件夹是否存在 File file = new File(\"D:\\\\upload\"); if(!file.exists())&#123; file.mkdirs(); &#125; FileOutputStream fileOutputStream = new FileOutputStream(file +\"\\\\\"+System.currentTimeMillis()+\".gif\"); int len = 0; byte[] bytes = new byte[1024 * 10]; while ((len = inputStream.read(bytes)) != -1) &#123; //写入本地 fileOutputStream.write(bytes, 0, len); &#125; accept.getOutputStream().write(\"接收完毕\".getBytes()); fileOutputStream.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; accept.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125;// server.close(); &#125;&#125; Client12345678910111213141516171819202122232425262728293031package file.upload;import java.io.*;import java.net.Socket;public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; FileInputStream file = new FileInputStream(\"D:\\\\vim.gif\"); byte[] bytes = new byte[1024 * 10]; int readLen = 0; Socket socket = new Socket(\"127.0.0.1\", 8000); OutputStream outputStream = socket.getOutputStream(); while ((readLen = file.read(bytes)) != -1) &#123;//=-1读取不到结束标记 //网络字节输出流 上传到服务器 outputStream.write(bytes,0,readLen); &#125; //禁用此套接字的输出流。对于TCP任何以前写入的数据都会被发送并且后面跟TCP的正常终止序列 socket.shutdownOutput(); //获取服务器输入流 接收服务器反馈 InputStream inputStream = socket.getInputStream(); while ((readLen = inputStream.read(bytes)) != -1) &#123; System.out.println(new String(bytes, 0, readLen)); &#125; file.close(); socket.close(); &#125;&#125;","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://blog.ojbkfeng.com/categories/网络编程/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://blog.ojbkfeng.com/tags/TCP/"}]},{"title":"Lambda表达式，闭包","slug":"JAVA/基础/Lambda","date":"2019-04-27T11:21:00.304Z","updated":"2019-05-01T03:08:49.316Z","comments":true,"path":"2019/04/27/JAVA/基础/Lambda/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/27/JAVA/基础/Lambda/","excerpt":"","text":"使用前提 必须具有接口，且接口中有且仅有一个抽象方法。(如Runnable、Comparable) 必须具有上下文推断：方法的参数具有的类型必须为Lambda对应的接口类型，才能使用Lambda作该接口的实例。 有且仅有一个接口的抽象方法，称为函数式接口。 格式(参数表) -&gt; {代码块(方法体)} -&gt; ： 把参数传给方法体{} ： 重写接口的方法体 1234567891011//普通写法new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;);//Lambda写法new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName());&#125;).start(); 1234567891011//普通写法invokeCalc(5, 6, new Calc() &#123; @Override public int plus(int a, int b) &#123; return a + b; &#125; &#125;);//Lambda形式invokeCalc(5, 6, (int a, int b)-&gt;&#123; return a + b; &#125;); Lambda的省略规则可推导的都可以省略 规则： ()内参数的类型可以省略 如果()内有且仅有一个参数，则()可以省略 如果{}内有且仅有一个语句，则{}可省略，并且语句后面的;要一起省略，return也可省略。 func(()-&gt;{return a+b}); 省略为func(()-&gt;a+b) 123// Lambda 省略形式new Thread(()-&gt; System.out.println(Thread.currentThread().getName())).start();new Thread(()-&gt; Thread.currentThread().getName()).start(); 12// Lambda 省略形式invokeCalc(4,5,(a,b)-&gt; a + b); Lambda引用的局部变量必须是 final闭包闭包是一个函数的实例，可以无限制地访问那个函数的非本地变量。闭包可以作为参数传递给另一个函数，也可以访问和修改其作用域之外的变量。限制：不能修改定义Lambda的方法的局部变量的内容，这些变量必须是隐式的final的。限制的原因是由于局部变量保存在栈上，并且隐式表示他们仅限于其所在的线程，如果改变会造成线程不安全的可能。 方法引用根据已有的方法来创建Lambda表达式，如下getAge是Student内的一个方法。 构建方法引用的三种方式123456789101112131415//1.指向静态方法的方法引用//Integer的parseInt方法Integer::parseInt//2.指向**任意类型实例**的方法//String的length方法String::length//3.指向**现有对象的实例方法**的方法引用//Student类中存age的方法Student::getAge//4.构造方法引用Supplier&lt;Scholar&gt; supplier = ()-&gt;new Scholar();//Lambda普通简化写法Supplier&lt;Scholar&gt; supplier = Scholar::new;//使用方法引用 进一步简化 1234//普通写法(Student a)-&gt;a.getAge()//方法引用Student::getAge 12345678()-&gt;Thread.currentThread().dumpStack()()-&gt;Thread.currentThread::dumpStack(str, i)-&gt;str.substring(i)String::substring(String s)-&gt;System.out.println(s)System.out::println","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ojbkfeng.com/categories/Java/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://blog.ojbkfeng.com/tags/函数式编程/"},{"name":"Lambda","slug":"Lambda","permalink":"https://blog.ojbkfeng.com/tags/Lambda/"}]},{"title":"线程的状态、同步和锁","slug":"JAVA/基础/多线程","date":"2019-04-20T04:37:48.846Z","updated":"2019-05-04T06:00:37.797Z","comments":true,"path":"2019/04/20/JAVA/基础/多线程/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/20/JAVA/基础/多线程/","excerpt":"","text":"线程的状态在import java.lang.Thread.State枚举类里列出了6种线程状态 状态 意义 NEW A thread that has not yet started is in this state.（创建后未调用start方法） RUNNABLE A thread in the runnable is executing in the Java virtual machine but it may waiting for other resources from the operating system such as processor.（可执行状态，可能在执行，也可能在等待其他os资源） BLOCKED A thread that is blocked(阻塞) waiting for a monitor lock(监视器锁) to enter注① a synchronized block/method or reenter a synchronized block/method after calling{@link Object#wait() Object.wait}. WAITING A thread that is waiting indefinitely for another thread to perform a particular action is in this state.(调用Object.wait())、Thread.join()、LockSupport.park()线程就会进入等待状态。注②) TIMED_WAITING A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.(调用Thread.sleep()、Thread.join()、Object.wait())、LockSupport.parkNanos()、LockSupport.parkUntil()方法就会进入TIMED_WATTING。) TERMINATED A thread that has exited is in this state. ①：java使用监视器同步模型实现的synchronized锁，synchronized的获取锁和释放锁字节码表示为monitorenter和monitorexit，因此这里的enter指的就是等待monitorenter。 ②：例如：调用Object.wait()方法进入WATTING的线程在等待另一个线程在这个对象调用Object.notify()或者Object.notifyAll()。调用Thread.join()的线程在等待指定线程终止。 1. Java中的线程java.lang.Threadjava中的线程是抢占调度模式，Java虚拟机允许并发执行多个线程，每个线程都有一个优先级，高优先级执行优于低优先级。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。 当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止： 调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。 非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。 每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。 创建线程方法1 继承Thread类，重写run()方法123456789101112class PrimeThread extends Thread &#123; public static void main()&#123; PrimeThread p = new PrimeThread(143); p.start(); &#125; @Override public void run() &#123; .... &#125;&#125; 方法二 实现Runnable接口，创建Thread类的时候把实现的接口作为参数传递1234567891011class PrimeRun implements Runnable &#123; public static void main()&#123; PrimeThread p = new PrimeThread(143); new Thread(p).start(); &#125; @Override public void run() &#123; .... &#125;&#125; 方法三 匿名内部类 创建线程runable同、123456new Thread()&#123; @Override public void run()&#123; .... &#125;&#125; 正在运行的线程static Thread currentThread() ：返回对当前正在执行的线程对象的引用。1Thread.currentThread().getName() 设置线程名称12Thread.setName();Thread.getName(); 线程睡眠static void sleep(long millis): 线程休眠。 线程同步(锁)synchronized同步代码块1234执行时获得锁 执行完毕释放锁sychronized(提供锁的对象，比如this)&#123; 临界代码&#125; synchronized同步方法123权限修饰 synchronized 返回值 方法名(...)&#123; 临界代码&#125; synchronized同步类权限修饰 synchronized class 。。。 synchronized静态代码块12345权限修饰 返回值 方法名(...)&#123; sychronized(RunnableImpl.class)&#123; 临界代码 &#125;&#125; ReentrantLock锁用java.util.concurrent.locks包下ReentrantLock类，它实现了Lock接口 void lock()获取锁 void unlock()释放锁 lockInterruptibly()获得锁，但优先响应中断 tryLock()尝试获得锁，成功返回true，失败返回false tryLock(long time, TimeUnit unit)在给定时间尝试获得锁 好处：无论程序是否有异常都能释放锁1234Lock lock = new ReentrantLock();lock.lock();...lock.unlock(); 什么是intrinsic lock(内在锁)和monitor lock(监视器锁)在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的，为了实现监视器的排他性监视能力，JVM为每一个对象和类都关联一个锁，锁住了一个对象，就是获得对象相关联的监视器。 扩展 JUC（Lock）和Monitor Object（Synchronized）机制区别 Java中锁和监视器有何区别？有何代码可以举例？","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ojbkfeng.com/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://blog.ojbkfeng.com/tags/多线程/"}]},{"title":"java 接口与抽象类","slug":"JAVA/基础/接口","date":"2019-04-07T03:16:46.804Z","updated":"2019-04-07T03:43:12.164Z","comments":true,"path":"2019/04/07/JAVA/基础/接口/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/07/JAVA/基础/接口/","excerpt":"","text":"语法区别 语法维度 抽象类 接口 关键字 abstract interface 参考文献《码出高效：java开发手册》","categories":[{"name":"java","slug":"java","permalink":"https://blog.ojbkfeng.com/categories/java/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://blog.ojbkfeng.com/tags/总结/"}]},{"title":"后端开发术语","slug":"后端开发/基础/后端开发术语","date":"2019-04-02T04:40:59.192Z","updated":"2019-04-07T03:16:21.718Z","comments":true,"path":"2019/04/02/后端开发/基础/后端开发术语/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/02/后端开发/基础/后端开发术语/","excerpt":"","text":"1. 系统吞吐量系统吞吐量表示了一个系统的承压能力，受到线程数、进程数、IO、请求对CPU的消耗等影响。单个请求对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。 1.1 TPS/QPSQPS(Queries Per Second):每秒能处理的请求个数，针对于单个接口或者服务。TPS(Transactions Per Second):每秒能处理的事务数，一个事物在分布式系统内可能对应多个请求。针对于整个分布式系统。（如果是单系统，则与QPS相同。 QPS（TPS）= 并发数/平均响应时间单位：Q/s或T/s 1.2 并发数某时刻系统能够同时处理的请求数量（QPS/TPS）。 1.3 响应时间（RT）表示处理一次请求所需的平均时间，包括CPU运算、IO、外部系统响应等时间组成。 2. 分布式与集群2.1 分布式(distributed) 微分布式系统 将不同的业务分布在不同的地方， 这就构成了一个分布式的系统，现在问题来了，系统A要分发整个系统，用户量访问大的时候要么是速度巨慢，要么直接挂掉，也就是单点失败。这时候就要用到集群了。 2.2 集群(Cluster)使用三个A系统，每一份都是系统A的一个实例,对外提供同样的服务，构成了一个系统群，访问数量多了就不会挂掉了。 A系统组成的集群（集群A系统） 但是每个系统的IP地址都不同，我们应该访问哪一个？如果只访问某一个还是会挂掉。这时候就要用到负载均衡了。 2.3 负载均衡(Load Balancer) 详细内容见标题8负载均衡，将请求分发到不同的服务器系统上，比如将3万个服务请求均匀分到集群A系统中的各个A系统中。(比如Nginx) 增加了负载均衡的集群A系统 虽然负载均衡只是接收请求、分发请求但是还是可能遇到最初的问题，单点失败。那么我们可以把负载均衡也搞成一个系统集群。 负载均衡集群+系统集群 这个新的集群中虽然有两个机器，但我们可以用某种办法，让这个集群对外只提供一个IP地址，也就是说用户看到的好像只有一个机器。同一时刻，我们只让一个负载均衡的机器工作，另外一个原地待命。如果工作的那个挂掉了，待命的那个就顶上去。 2.4 弹性如果这3个系统A的实例还是满足不了大量的请求，那就再加服务器！双11来了，用户量是平时的10倍这时候有两个方案：① 方案一：购买十几个服务器。② 方案二：使用云主机（云计算）。如果使用①，双十一过后，访问数下降，新购的主机就成了摆设，什么卵用都没了，造成了浪费。如果使用②，在购置的云服务上自由添加删除虚拟机，就不会造成浪费，这就叫弹性。 2.5 失效转移上面的系统看起来很美好，但是做了一个不切实际的假设：所有的服务都是无状态的。换句话说，假设用户的两次请求直接是没有关联的。实际上，大多数请求都是有状态的，比如说：购物车。如果在服务器1.1上创建一个购物车，并且向其中加入了几个商品，然后1.1挂掉了，被其他服务器接管，那么问题来了，其他服务器上没有1.1里创建的那个购物车，该怎么办？还有登录，如果把用户的登录保存在1.2的session中，1.2挂了，用户又被跳转到登录界面了，怎么办？解决方案：① 把状态信息在集群的各个服务器之间复制，让集群的各个服务器达成一致。(Websphere, Weblogic)② 把状态信息存在统一的一个服务器里，让各个集群里的服务器都能找到。 存储在同一服务器 3. 高性能3.1 高性能的定义3.1.1 后台系统中的“高性能”主要包括两部分： 尽可能多地榨干单台计算机的性能。 尽可能高的利用计算机集群的能力。 3.1.2 操作系统和性能最相关的就是进程和线程： 每个进程占据独立内存空间，CPU分片串行处理，进程通信，操作系统分配资源的最小单位。 线程是进程内部的子任务，共享同一份进程数据，多线程并发，互斥锁，操作系统调度的最小单位。 它们的存在是为了让计算机在 IO 或者网络时，CPU 仍然能忙碌着。具体实现采用多进程还是多线程，不同的业务可能适合不同的方式，没有最好的选择。 Nginx可以用多进程也可以用多线程；JBoss采用的是多线程；Redis采用的是单进程；Memcache 采用的是多线程。 3.2 计算机集群的高性能拥有计算机集群是提升性能的第一步，第二步就是如何让多台机器配合起来达到高性能。主要有两种方式： 任务分配 任务分解 3.2.1 任务分配指的是在客户端和业务服务器之间增加一层任务分配器，他们的作用就是负责分配任务给合适的机器。这个分配的复杂点在于，任务分配的算法和任务分配器多了，还需要负责分配给任务分配器的分配器。 任务分配 3.2.2 任务分解指的是将不同的业务系统分配到不同的机器上，把原本大一统但复杂的系统，拆分成多个简单但需要配合的系统，然后再针对部分访问量大的系统做优化。 任务分解 4. 高可用高可用指的是系统无中断地执行器功能的能力。难点就在于“无中断”，无论硬件还是软件都会逐渐不可用，比如硬件会逐渐老化，软件会逐渐复杂不好维护。软件系统的高可用主要是通过增加冗余机器实现的，一般包括两种： 计算高可用 存储高可用 4.1 计算高可用“计算”指的是业务逻辑，计算高可用的目的是无论在哪台机器上执行业务逻辑，最后的结果都一致。 和前面高性能一样，同样需要有一个任务分配器来分配业务给主服务器或备服务器： 4.2 存储高可用我们知道，数据 + 逻辑 = 业务。存储高可用的目的是尽可能地保证数据在不同机器上都是一致的。阻碍：由于数据从一台机器搬到另一台机器需要时间，不同地理位置、不同网络状况下需要的时间各不同。对于整个系统而言，在某个时间点上，数据一定是不一致的，最后会导致业务出问题。存储高可用的难点在于如何减少或者规避数据不一致导致的业务异常。 5. 状态决策无论计算高可用还是存储高可用，本质上都是通过冗余实现。系统需要能够根据当前状态做出决策，一般有三种决策方式： 独裁式 只有一个独立的决策者，其余冗余的个体不参与决策。优点是简单，缺点是决策者故障时系统就会故障。 协商式 两台机器通过交流信息，根据规则进行决策，比如主备决策。难点在于规则的确定和信息交换异常的处理。 选举式 通过投票的方式来进行状态决策。难点在于算法复杂，还有可能乎产生“脑裂”。 6. 可拓展可扩展性是指系统应对需求变化的一种扩展能力。当新需求出现时，可以不修改或者尽可能少的修改即可支持。 设计可扩展的系统，主要有两步： 正确预测变化 结合行业业务发展方向，预测未来技术方向 结合公司业务发展规模，预测高性能、高可用相关压力 适度预测，不要过度设计 完美封装变化 拆分出变化层和稳定层 设计变化层和稳定层之间的接口 7. 数据库集群在业务复杂到一定程度后，数据库服务器也需要集群，数据库集群一般有两种实现方式： 读写分离 分库分表 8. 负载均衡常见的负载均衡主要有三种： DNS 负载均衡 硬件负载均衡 软件负载均衡 8.1 DNS 负载均衡8.2 硬件负载均衡8.3 软件负载均衡未完待续未完待续未完待续未完待续未完待续未完待续幂等性防止下订单一大波点击提交1）利用乐观锁 通过版本号去控制 2）悲观锁也行 select * from xx for update 悲观锁和乐观锁的区别 参考资料 后端术语快速扫盲 分布式和集群","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ojbkfeng.com/categories/后端/"}],"tags":[{"name":"术语","slug":"术语","permalink":"https://blog.ojbkfeng.com/tags/术语/"}]},{"title":"基本类型、static关键字","slug":"JAVA/基础/基础","date":"2019-04-01T08:46:12.358Z","updated":"2019-04-07T03:18:06.967Z","comments":true,"path":"2019/04/01/JAVA/基础/基础/","link":"","permalink":"https://blog.ojbkfeng.com/2019/04/01/JAVA/基础/基础/","excerpt":"","text":"1.基本类型和包装类 基本类型 包装类 byte Byte short Short int Integer float Float long Long double Double char Character boolean Boolean ①除了以上几种基本类型，其他的都是引用类型，包装类也是引用类型(引用类型默认值为null)。②基本类型和包装类型可以互相自动装箱，拆箱。③类型转换只能由小到大。 2. static 关键字2.1 修饰成员函数① 用static修饰的函数可以直接由调用，不用创建对象。② 静态方法，推荐用类名称调用，不推荐使用对象名访问。③ 使用对象名调用static方法，会被编译成类名调用。④ 常用的有Integer.parseInt()之类的。⑤ 静态方法不能直接访问非静态变量。（内存中先有静态内容，后有动态内容）⑥ 静态方法中不能使用this关键字。12345678910public class Test &#123; public static void main(String[] args) &#123; TestStatic.testa(); &#125;&#125;class TestStatic&#123; public static void testa()&#123; System.out.println(\"ok\"); &#125;&#125; 2.2 修饰成员变量static修饰的成员变量的所有实例共享同一个数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test &#123; public static void main(String[] args) &#123; Student a = new Student(\"李华\", 16); a.setClassRoomNumber(101); //李华 16 101 1 System.out.println(a.getName()+\" \"+ a.getAge()+\" \"+a.getClassRoomNumber()+\" \"+a.getId()); Student b = new Student(\"黎明\", 15); //李华 16 101 2 System.out.println(a.getName()+\" \"+ a.getAge()+\" \"+a.getClassRoomNumber()+\" \"+a.getId()); //黎明 15 101 2 System.out.println(b.getName()+\" \" + b.getAge()+ \" \"+b.getClassRoomNumber()+\" \"+b.getId()); &#125;&#125;class Student&#123; private String name; private Integer age; private static Integer classRoomNumber; private static Integer id=0; Student(String name, Integer age) &#123; this.name = name; this.age = age; this.id = ++id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setClassRoomNumber(Integer classRoomNumber) &#123; this.classRoomNumber = classRoomNumber; &#125; public Integer getClassRoomNumber() &#123; return classRoomNumber; &#125; public Integer getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public static Integer getId() &#123; return id; &#125;&#125; 2.3 静态代码块① 当第一次使用到此类的时候，静态代码块执行唯一的一次② 第一次实例化的时候会执行！第一次调用该类的静态方法也会执行。但不管任意方式执行，都只能执行唯一一次，实例化执行后调用静态方法就不会执行，反之亦然。③ ※ 用来一次性的对静态变量赋值！12345public class Test&#123; static &#123; //静态代码块 &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.ojbkfeng.com/categories/java/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://blog.ojbkfeng.com/tags/总结/"}]},{"title":"adb command","slug":"Android/adb","date":"2019-03-06T11:01:24.335Z","updated":"2019-03-07T08:43:03.370Z","comments":true,"path":"2019/03/06/Android/adb/","link":"","permalink":"https://blog.ojbkfeng.com/2019/03/06/Android/adb/","excerpt":"","text":"1. Debugging1.1 adb devices列出设备。 1.2 adb start-server启动服务。 1.3 adb kill-server结束服务。 1.4 adb wait-for-device一直等待设备连接。block until device is online. 2. Package Manager2.1 adb install app.apk2.2 adb uninstall &lt;pkgname>adb uninstall com.zhihu.android 2.3 adb shell pm list packages打印所有的包。 -f 查看文件关联 -d (disabled)查看已禁用的包 -e (enabled)已启用的包 -s 系统包 -3 第三方包 -i 查看已安装的包 -u 所有包，包括已卸载的包 –user &lt;USER_ID&gt; The user space to query.用户空间的包。2.4 adb shell pm path &lt;PACKAGE>打印指定包的apk路径。1adb shell pm path com.zhihu.android 2.5 adb shell pm clear &lt;PACKAGE>adb shell pm path com.zhihu.android 清除数据和缓存。 3. File Manager3.1 adb pull &lt;remote> [local]adb pull /target-file-path/filename.ext /localpath 3.2 adb push [local] &lt;remote>同pull。 adb push /localpath/filename.ext /target-path 3.3 adb shellls -a 不隐藏.开头的 -i 给每个文件加上数字索引 -s 以blocks为单位打印每个文件的大小 -n 列出UIDs和GIDs -R 以递归方式列出子目录cd你懂的。rm -f 强制删除，且不提示。 -r 以递归方式删除目录内容 -d 删除目录，即使是非空(rm -d等于rmdir) -i 删除前提示mkdirmkdir [options] 直接创建 mkdir /sdcard/wtf 顺便加个权限 mkdir -m 777 /sdcard/wtf 根据需要创建父目录 mkdir -p /sdcard/wtf/sub1/sub2 touch创建文件。 pwd当前路径。 cpcp /当前/test.txt /目标/demo.txt 还能顺便改个名 mvmv /当前/tmp /目标/tmp 改名 mv /sdcard/wtf /sdcard/test 4. Network4.1 netstat1adb shell netstat ↓↓↓↓↓1234Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 127.0.0.1:5037 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:5555 0.0.0.0:* LISTENtcp 0 0 10.0.2.15:5555 10.0.2.2:54444 ESTABLISHED 4.2 ping需要Ctrl+c结束1adb shell ping www.baidu.com 4.3 netcfg12通过配置文件配置管理网络。netcfg [&lt;interface&gt; &#123;dhcp|up|down&#125;] 123456# netcfgnetcfglo UP 127.0.0.1 255.0.0.0 0x00000049eth0 UP 10.0.2.15 255.255.255.0 0x00001043tunl0 DOWN 0.0.0.0 0.0.0.0 0x00000080gre0 DOWN 0.0.0.0 0.0.0.0 0x00000080 4.4 ipshow, manipulate routing, devices, policy routing and tunnels.展示和操作路由、设备、路由规则和隧道。12345ip [ OPTIONS ] OBJECTOBJECT := &#123; link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp &#125;OPTIONS := &#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] &#123; inet | inet6 | ipx | dnet | link &#125; |-l[oops] &#123; maximum-addr-flush-attempts &#125; |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]&#125; ip -f inet addr show wlan0 //WiFi的地址 4.5 reverse手机跟电脑在不同网络的时候，电脑的本地API服务手机无法访问，reverse后，手机访问http://localhost:8000时，被路由到localhost:30001adb reverse tcp：8000 tcp：3000 5. Logcat12打印日志数据到屏幕。adb logcat [option] [filter-specs] adb logcat 直接打印Ctrl + c停止 adb logcat *:V 最低优先级，只显示详细级别Verbose level *:D 只显示debug级别Debug level *:I info level *:W warning level *:E error level *:F 致命程度Fatal level *:S 最高优先级，不打印任何内容 1adb logcat -v &lt;format&gt; adb logcat -v brief 显示发出消息的进程的优先级、标记和PID(默认格式)。 adb logcat -v process 只显示PID。 adb logcat -v tag 只显示优先级和标签。 adb logcat -v raw 显示原始数据，没有其他元数据字段。 adb logcat -v time 显示发出消息的进程日期，调用时间，优先级，标记和PID。 adb logcat -v threadtime 同上，增加TID。 adb logcat -v long 显示所有元数据字段，并用空格分割。 1adb logcat -b &lt;Buffer&gt; adb logcat -b radio 只显示收音机和电话的消息缓冲区。 adb logcat -b event 只看事件相关的缓冲区。 adb logcat -b main 默认 其他 adb logcat -c 清除所有日志并退出 adb logcat -d 将日志转储到屏幕并退出 adb logcat -f test.log 将日志消息转入test.log adb logcat -g 打印指定日志并退出 adb logcat -n 将最大旋转日志(rotated logs)设置为count adb logcat -r 每kbytes输出旋转日志文件。最大默认值为4，用-r指定。 adb logcat -s 将默认过滤器设置为静默，默认16，-f指定。 12转储系统数据。adb shell dumpsys [options] adb shell dumpsys 直接查看 adb shell dumpsys battery 直接查看 adb shell dumpsys batterystats 为设备收集电池数据(android 5.0以上) adb shell dumpsys batterystats –reset 删除旧的数据。 1转储状态。(dumps State) adb shell dumpstate 直接查看 adb shell dumpstate &gt; state.logs 存入文件 6. Screen operation6.1 screencap(截图)1234//截图adb shell screencap /sdcard/screen.png//配合pull保存到电脑adb pull /sdcard/screen.png 6.2 screenrecord[4.4+]（录屏）Android 4.4+版本支持。录屏，Ctrl+c停止或3分钟或-time-limit设置的时间限制内自动结束。1adb shell screenrecord [options] &lt;filename&gt; adb shell screenrecord /sdcard/wtf.mp4 默认设置直接录制。 adb shell screenrecord –size 设置视频分辨率。1280x720 adb shell screenrecord –bit-rate 设置视频的比特率，默认值为4Mbps,例如5Mbps参数为–bit-rate 5000000 /path/wtf.mp4 adb shell screenrecord –rotate 设置最长录制时间，默认值180秒。 adb shell screenrecord –verbose 将输出旋转90度。7. system7.1 adb root用root权限重启adbd守护进程。(只能用于模拟器)adb root7.2 adb sideloadflashing/restoring Android update.zip packages.刷新/恢复安卓update.zip包。adb sideload &lt;update.zip&gt;7.3 adb shell ps跟Linux差不多。7.4 adb shell top top 显示CPU顶级进程。 top -t 显示线程7.5 adb shell getprop通过安卓属性服务获取属性。12345678910adb shell getprop----输出----[ro.secure]: [0][ro.allow.mock.location]: [1][ro.debuggable]: [1][persist.service.adb.enable]: [1][ro.kernel.qemu.gles]: [0][ro.kernel.qemu]: [1][ro.kernel.console]: [ttyS0][ro.kernel.android.qemud]: [ttyS1] 12//获取构建sdk版本adb shell getprop ro.build.version.sdk 7.6 adb shell setprop可以修改getprop可以获得的信息。将adb端口设置为5555setprop service.adb.tcp.port 5555","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.ojbkfeng.com/categories/Android/"}],"tags":[{"name":"debug tools","slug":"debug-tools","permalink":"https://blog.ojbkfeng.com/tags/debug-tools/"}]},{"title":"class, object, type之间的关系","slug":"python/class,type,object","date":"2019-02-27T01:22:56.423Z","updated":"2019-03-06T11:03:04.252Z","comments":true,"path":"2019/02/27/python/class,type,object/","link":"","permalink":"https://blog.ojbkfeng.com/2019/02/27/python/class,type,object/","excerpt":"","text":"类是type生成的对象1234567type(1) # inttype(int) # type#type -&gt; int -&gt; 1#type -&gt; class -&gt; objecttype.__bases__ # objecttype(object)object.__bases__ #() object是顶层基类type是一个类，也是一个对象","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[]},{"title":"在win上用Linux命令","slug":"cmd扩展Linuxbash命令","date":"2019-01-29T08:05:26.062Z","updated":"2019-01-29T08:23:08.149Z","comments":true,"path":"2019/01/29/cmd扩展Linuxbash命令/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/29/cmd扩展Linuxbash命令/","excerpt":"","text":"clink（记录命令）官网可以用来记录命令，cmd本身不带有这功能，关闭后，就不知道上次用了啥命令了。ctrl + r可以检索历史命令。 gow(支持Linux命令)github项目页(指不定啥时候就关了)随便安装在哪里，安装完成后打开cmd，输入ls，显示目录就OK了。Gow-0.8.0.exe GNU bash(解决gow的一些问题)下载页(指不定啥时候凉了)由于指不定啥时候就凉了所以我就下好保存起了。bash-203.zip只要用里面的ls.exe文件替代gow安装目录中的/bin目录下的ls.exe文件就可以解决无法显示中文的问题了。使用方式有一丢丢区别，gow的ls直接显示在cmd命令下，bash的显示方式不同，如果使用ls -l | less这种的话，按q退出。 需要用到的文件","categories":[{"name":"折腾永无止境","slug":"折腾永无止境","permalink":"https://blog.ojbkfeng.com/categories/折腾永无止境/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://blog.ojbkfeng.com/tags/bash/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.ojbkfeng.com/tags/cmd/"}]},{"title":"冒泡排序","slug":"算法与数据结构/算法_冒泡排序","date":"2019-01-29T06:11:52.401Z","updated":"2019-05-08T01:52:58.810Z","comments":true,"path":"2019/01/29/算法与数据结构/算法_冒泡排序/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/29/算法与数据结构/算法_冒泡排序/","excerpt":"","text":"维基百科 C++实现适用于整形和浮点型。12345678template&lt;typename T&gt;void bubble_sort(T arr[], int len) &#123;4int i, j;4for (i = 0; i &lt; len - 1; i++)44for (j = 0; j &lt; len - 1 - i; j++)444if (arr[j] &gt; arr[j + 1])4444std::swap(arr[j], arr[j + 1]);&#125; Python12345678def bubble_sort(iterable): sorting = list(iterable) length = len(sorting) for i in range(length -1): for j in range(length - 1, i, -1): if sorting[j] &lt; sorting[j - 1]: sorting[j], sorting[j - 1] = sorting[j - 1], sorting[j] return sorting JavaScript1234567891011Array.prototype.bubble_sort = function() &#123;var i, j, temp;for (i = 0; i &lt; this.length - 1; i++)4for (j = 0; j &lt; this.length - 1 - i; j++)44if (this[j] &gt; this[j + 1]) &#123;4444temp = this[j];4444this[j] = this[j + 1];4444this[j + 1] = temp;444&#125;return this;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ojbkfeng.com/categories/算法/"}],"tags":[{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://blog.ojbkfeng.com/tags/冒泡排序/"}]},{"title":"Python re 模块","slug":"python/python re","date":"2019-01-26T06:13:24.145Z","updated":"2019-03-07T06:40:56.723Z","comments":true,"path":"2019/01/26/python/python re/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/26/python/python re/","excerpt":"","text":"1.函数表 函数 作用 match 在字符串起始位置匹配，如果没有匹配到返回None。 fullmatch 用表达式匹配所有字符串 search 匹配任意位置的字符串 sub 替换字符串中匹配成功项。 subn 同上，返回替换次数 split 把查找到的字符串分割，并且打包成列表返回 findall 匹配字符串中所有匹配的项，打包成列表返回 finditer 同上，但是返回的是迭代器 compile 编译正则表达式(pattern)，生成一个正则表达式对象(RegexObject)，仅供match()和search()函数使用。 purge 清除缓存 escape 除了ASCII字母，数字和以外，转义模式中的所有字符 2.可选标志 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，会影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。会标志影响 \\w, \\W, \\b, \\B. 3.re.match()在字符串开头匹配。函数原型：re.match(pattern, string, flags=0)匹配成功：返回匹配的对象匹配失败：返回None 参数 意义 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 可选标志位，用于控制正则表达式的匹配方式 12345678910# 在字符串开头匹配到返回一个对象print(re.match('blog', 'blog.ojbkfeng.cn'))# &lt;_sre.SRE_Match object; span=(0, 4), match='blog'&gt;# 在开头处没匹配到返回Noneprint(re.match('cn', 'blog.ojbkfeng.cn'))# Noneprint(re.match('blog', 'blog.ojbkfeng.cn').span())# (0, 4) 1234567891011strings = \"what the fuck ???\"reg = re.match(r'(.*) the (.*?) .*', strings, re.M|re.I)if reg: print(reg.group()) # what the fuck ??? print(reg.group(1)) # 匹配到的第一个 # what print(reg.group(2)) # 第二个 # fuckelse: print( \"No match!!\") 4.re.search()在整个字符串匹配，并返回成功的第一个。函数原型：re.search(pattern, string, flags=0)匹配成功：返回匹配的对象。匹配失败：返回None。参数同match(), 用法相同。 5.re.sub()替换字符串中匹配成功项。函数原型：re.sub(pattern, repl, string, count=0, flags=0) 参数 意义 pattern 正则中的模式字符串。 repl 替换的字符串，也可为一个函数。 string 要被查找替换的原始字符串。 count 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 123strings = \"188-7438-6478\"num = re.sub(r'\\D', \"\", strings)print(num) # 18874386478 6.re.compile()编译正则表达式(pattern)，生成一个正则表达式对象(RegexObject)，仅供match()和search()函数使用。函数原型：re.compile(pattern[, flags])pattern : 一个字符串形式的正则表达式flags : 可选标志，文章上面有参数表。1234strings = \"188-7438-6478\"reObj = re.compile(r'\\D')num = re.sub(reObj, \"\", strings)print(num) # 18874386478 7.re.split()按照能够匹配的子串将字符串分割后返回列表。函数原型re.split(pattern, string[, maxsplit=0, flags=0])maxsplit：分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数其余参数与match()相同。12re.split('\\W+', 'ojbk, ojbk, ojbkfeng.')# ['ojbk', 'ojbk', 'ojbkfeng', ''] 8.findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 跟match()和search()不同的是findall()匹配所有出现过的字符串，match和search只匹配一次。函数原型：findall(string[, pos[, endpos]]) 参数 意义 string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 9.re.finditer()跟findall()一样，区别是返回一个迭代器(iter)。函数原型：re.finditer(pattern, string, flags=0)","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/"},{"name":"Python","slug":"正则表达式/Python","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/Python/"}],"tags":[{"name":"Python内置模块","slug":"Python内置模块","permalink":"https://blog.ojbkfeng.com/tags/Python内置模块/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-01-26T04:45:50.932Z","updated":"2019-01-26T06:27:45.144Z","comments":true,"path":"2019/01/26/正则表达式/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/26/正则表达式/","excerpt":"","text":"特殊字符表Python re模块由于渲染问题下面表格的|使用I代替。 特殊字符 意义 示例 . 默认情况下匹配除了换行符以外的任何字符，在DOTALL模式下，可以匹配任意字符 a.c ^ (Caret)插入符，匹配起始位置的字符串，在MULTILINE模式下，可以在换行后继续匹配。 ^Hello $ 匹配结束的字符串，也可用MULTILINE模式 abc.$匹配abc1\\n * 匹配*前的字符0个或n个 ab*匹配’a’、’ab’、’a’或含有n个b的abbbb + 匹配一个或多个前面的字符。 a+匹配ab和aaab，但与a*和a?不同的是, 模式a+不会匹配开始处没有’a’的字符串. ? 使得到的RE匹配前面RE的0或1次重​​复。 ab?将匹配’a’或’ab’。 {m} 次数限定符，匹配出现对应次数的字符串。 a{2}匹配aa {m,n} 次数区间限定符，同上。左右都闭区间。 a{1,2}匹配ab中的‘a’，然而匹配aaaab就只能匹配到前面两个a。 \\ 转义字符，用来匹配特殊字符。 \\. [ ] ①表示一组字符；② ‘(‘, ‘+’, ‘*’, 或 ‘)’之类的特殊字符在[]里就失去意义了，只能表示字面意思。③^的意义改变成除……以外的其他字符 ①[0-9A-Za-z]表示匹配所有的字符和数字；②[abc]匹配’a’,’b’或’c’ ③ [^^]表示除了^以外的所有字符,[^a]除a以外 AIB 将一个或多个可选字符分隔开 grayIgrey匹配gray或grey,也可以写成gr(aIe)y (…) 确定求值顺序，(?...)特殊模式，不区分大小写和多行 (abc)+匹配abcabc666中的所有abc但不匹配ab或者bc等 \\A 只匹配开头的字符串 \\b 在字符串的开头或结尾匹配空字符串 \\B 匹配一个不再字符串开头或结尾的空字符串 \\d 匹配一个数字 \\D 匹配一个非数字 \\w 匹配Unicode字符,任何语言的字符，包括数字下划线 \\W 匹配不是单词字符的字符，相当于[^A-Za-z0-9_] \\s 对于Unicode字符，匹配空格，包括[ \\t\\n\\r\\f\\v]，对于8-bit字符串考虑有空格的字符 \\S 匹配不是空格的字符 贪婪模式*, +, ?, {min,max}默认情况下都是贪婪的(尽可能多匹配), 例如：&lt;.*&gt;匹配&lt;a&gt; b &lt;c&gt;会将整个字符串全部匹配。添加限定符？后将解除这个模式&lt;.*?&gt;将只匹配到&lt;a&gt;。a{3,5}?将只匹配aaaaaa中的前3个。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/tags/正则表达式/"}]},{"title":"cmd常用命令","slug":"cmd","date":"2019-01-25T14:16:19.906Z","updated":"2019-01-25T15:46:17.980Z","comments":true,"path":"2019/01/25/cmd/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/25/cmd/","excerpt":"","text":"官方文档 帮助命令+ /?显示帮助文档例如：taskkill /?arp /?help + 命令 显示帮助（不推荐使用）速度很慢，查找内容超级多。但是用来查看echo的帮助还是可以的，help echo，如果用echo /?的话是什么效果你可以试试。下面是在cmd里使用了帮助需要注意的： 符号 描述 没有括号或大括号的文本 必须显示输入的 &lt;尖括号内的文字&gt; 必须为其提供值的占位符 [方括号内的文字] 可选项目 {文字里面的大括号} 必要的参数; 选一个 垂直条（I） 互斥元素的分隔符; 选一个 省略号（…） 可以重复的项目 注：垂直条是|,由于用的markdown上面无法解析，所以用I替代了。 taskkill使用该工具按照进程 ID (PID) 或映像名称终止任务。 关闭PID号为3716和123的进程/F：强制taskkill /pid 3716 /pid 123 /F 关闭所有记事本taskkill /IM notepad.exe where（超实用）显示符合搜索模式的文件位置。在默认情况下，搜索是在当前目录和 PATH环境变量指定的路径中执行的。where gcc 显示gcc解释器的地址where /r c:\\ test 查找c盘里的名字是test的文件 whoamiwhoami 显示当前用户whoami /all 显示当前用户所有信息 cls（清空面板）defrag（磁盘整理）整理C盘并且显示进度和详细信息defrag C: /U /V echo（显示内容，便于debug）打印path信息：echo %PATH% find搜索文件或文件中的文本字符串，并显示包含指定字符串的文本行。 /V 显示所有未包含指定字符串的行。 /C 仅显示包含字符串的行数。 /N 显示行号。 /I 搜索字符串时忽略大小写。 /OFF[LINE] 不要跳过具有脱机属性集的文件。 “string” 指定要搜索的文本字符串。 [drive:][path]filename 指定要搜索的文件。 findstr在文件中寻找字符串。通常与其他命令搭配使用例如netstat -ano|findstr 5000查找端口号5000的进程详情见 findstr /? ipconfig&gt; ipconfig ... 显示信息 &gt; ipconfig /all ... 显示详细信息 &gt; ipconfig /renew ... 更新所有适配器 netstat显示协议统计信息和当前 TCP/IP 网络连接。常用组合：netstat -nb 显示所有活动连接(网络连接)。netstat -o 显示路由表 查找5000端口进程netstat -ano|findstr 5000 perfmon（性能监控）perfmon /RES ：显示资源监控，包括TCP连接、网络活动(网络IO)、网络活动的进程。 set（操作环境变量）显示、设置或删除 cmd.exe 环境变量。SET [variable=[string]] variable 指定环境变量名。 string 指定要指派给变量的一系列字符串。 tasklist（任务列表）ftp将文件传送到运行 FTP 服务器服务(经常称为后台程序)的计算机以及将文件从该计算机传出。可以交互使用 Ftp。 title 命令窗的标题title wtf？？ tree（显示文件结构）TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。例如：显示磁盘所有文件，|more是懒加载。tree c:\\ /f | more","categories":[{"name":"终端","slug":"终端","permalink":"https://blog.ojbkfeng.com/categories/终端/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://blog.ojbkfeng.com/tags/cmd/"}]},{"title":"Python mysqlclient模块连接MySQL","slug":"python/mysqlclient","date":"2019-01-17T09:07:18.267Z","updated":"2019-01-18T04:35:37.159Z","comments":true,"path":"2019/01/17/python/mysqlclient/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/python/mysqlclient/","excerpt":"","text":"1.所需库mysqlclient2.遇到问题2.1安装时出现错误：无法打开“mysql.h”2.1.1解决方案 1.这是我从Stack Overflow上找的几个回答综合在一起得出的最OK解决方案：2.所需要的文件：&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python：https://downloads.mysql.com/archives/c-python/&ensp;&ensp;&ensp;&ensp;编译好的whl文件：https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient.Then&ensp;&ensp;&ensp;&ensp;我下的是mysqlclient-1.3.13-cp36-cp36m-win_amd64.whl 和 mysql-connector-python-8.0.12-py3.6-windows-x86-64bit.msi 版本&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python的安装会一闪而过 安装好后有两个新的包 安装好后会遇到mysql-connector-python 8.0.12 requires protobuf&gt;=3.0.0, which is not installed.直接安装protobuf即可，不安装也不影响根据需求而定 3.mysqlclient 官方GitHub主页4.使用portable的接口MySQLdb 连接的构造函数connect(arg,\\*args)必填参数(host，user，passwd，db，port,)对应参数(主机名称，用户名，密码，数据库名，mysqlserver的tcp端口，)其他参考官方主页或源代码123456789101112131415161718192021import MySQLdb #千万注意大小写#获取连接,传入参数错误或连接远程主机断开等会抛出异常try: conn = MySQLdb.connect( host = \"localhost\", #或127.0.0.1 port = 3306, #mysql默认端口3306 user = \"root\", #用户名 passwd = \"feng\", #密码 db = \"flask_obj\", #数据库名称 charset = \"utf8\" #数据库编码)cursor = conn.cursor() #创建游标cursor.execute('select * from `test` ') #传入查询语句result=cursor.fetchone() #查找一条数据，返回tupleprint(result) # (1, '2')cursor.close() #关闭游标conn.close() #关闭连接except MySQLdb.Error as e: print(\"Error: %s\" % e)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ojbkfeng.com/tags/MySQL/"},{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/tags/Python/"}]},{"title":"markdown从基础到癫疯","slug":"markdown语法","date":"2019-01-17T09:04:56.047Z","updated":"2019-01-17T10:54:44.275Z","comments":true,"path":"2019/01/17/markdown语法/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/markdown语法/","excerpt":"","text":"1.标题# 空格 标题 一级标题二级标题………. 六级标题# 一级标题 ## 二级标题 .......... ###### 六级标题 2.字体2.1加粗需要加粗的字前后分别用两个*包含起来 **加粗** 加粗 2.2斜体加粗跟加粗类似，前后用三个*包含起来 ***斜体加粗内容*** 斜体加粗字 2.3斜体斜体前后分别用一个*包含加来 *斜体* 斜体 2.4删除线前后分别两个~ ~~删除线~~ 删除线 3.引用使用&gt;符号表示在&gt;后面书写内容，可以使用连续的&gt;添加多级引用，感觉没什么卵用 &gt;我是引用 &gt;&gt;我是嵌套引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我是引引引引引引引引引用 我是引用 我是嵌套引用 我是引引引引引引引引引用 4.分割线用三个以上下列符号就行了，不建议使用三个组，如***有可能跟加粗斜体冲突 --- ---- *** ***** 5.图片![图片下显示的字](图片地址) 示例： ![sogou上的表情包](http://img02.sogoucdn.com/app/a/100520021/AB4384FE85BE242D5AF8607534289248) 效果如下： sogou上的表情包 6.超链接[超链接名](超链接地址) 跟图片的区别就是少了个！ [lz的主页](https://blog.ojbkfeng.cn) lz的主页 7.列表无序列表用下面任意一种就行,可以嵌套，可以跟有序列表混合嵌套。 - 列表内容 - 嵌套列表 + 列表内容 * 列表内容 列表内容 嵌套列表 列表内容 列表内容 有序列表 直接用数字序列替代前面的符号即可。 8.表格 |姓名|技能|排行| |:–|:–:|–:| 这一行分别是左对齐，居中，右对齐 |张三|吃屎|老三| |张二|喝尿|老二| |张大|张三张二会的他都会|老三| 姓名 技能 排行 张三 吃屎 老三 张二 喝尿 老二 张大 张三张二会的他都会 老三 9.代码块单行代码前后一个`反引号。 `list = [x for i in range(1,100000,2)]` list = [x for i in range(1,100000,2)] 多行代码前后用三个反引号`，前面三个反引号后面要加代码名，比如c 比如python 反引号反引号反引号pythonl = [x for i in range(1,100000,2)]print(l)反引号反引号反引号12l = [x for i in range(1,100000,2)]print(l) 10.流程图我这个是GitHub存储的，GitHub不支持流程图，模板用的hexo，默认也不支持流程图，但是hexo可以用插件强行支持。npm install --save hexo-filter-flowchart 反引号反引号反引号(由于渲染问题，我就用这个代替三个`了)flow —-定义部分格式： 变量名=&gt;模块名: 内容—- st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end —-流程控制部分格式：变量-&gt;变量—- st-&gt;op-&gt;cond cond(yes)-&gt;e —cond(yes)表示判断为yes执行的路线 cond(no)-&gt;op 反引号反引号反引号 操作模块 说明 start 开始 end 结束 opration 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 st=>start: 开始 op=>operation: Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"markdown","slug":"markdown","permalink":"https://blog.ojbkfeng.com/categories/markdown/"}],"tags":[{"name":"markdown基础","slug":"markdown基础","permalink":"https://blog.ojbkfeng.com/tags/markdown基础/"}]},{"title":"Ubuntu 16.04更新pip版本后无法使用","slug":"python/Ubuntu_pip_updata","date":"2019-01-17T08:56:20.422Z","updated":"2019-01-18T04:25:11.463Z","comments":true,"path":"2019/01/17/python/Ubuntu_pip_updata/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/python/Ubuntu_pip_updata/","excerpt":"","text":"1.首先卸载掉之前的pip sudo apt-get remove python-pip （卸载python2的pip）sudo apt-get remove python3-pip （卸载3版本的pip3） 2.安装pip sudo apt-get install python3-pip (安装python3） 3.可能遇到的问题 #####如果安装遇到更新apt-get问题 image.png apt-get update （更新代码） #####更新完毕后使用下列代码重新安装pip sudo apt-get install python3-pip （python3的pip）sudo apt-get install python-pip （python2的pip） #####遇到如下kernel版本问题，直接回车OK会自动更新至支持libc6的对应版本内核 image.png 更新完毕后会自动安装pip，此时输入安装pip代码（ sudo apt-get install python3-pip）会提示已安装 image.png 输入pip/pip3 -v 查看pip版本，pip回退成功！ pip3 -Vpip -V image.png","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://blog.ojbkfeng.com/tags/pip/"}]},{"title":"Python数据结构：队列及其应用","slug":"算法与数据结构/队列","date":"2019-01-17T08:44:35.355Z","updated":"2019-01-18T04:25:14.224Z","comments":true,"path":"2019/01/17/算法与数据结构/队列/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/算法与数据结构/队列/","excerpt":"","text":"1.什么是队列？队列是一种遵循先进先出的原则（First In First Out）d的数据结构。Python标准库里就有Queue类，标准库导入方法import queue 。 标准库中的queue标准库中的queue是线程安全的，并且使用了协程。 基于线程锁的asyncio Queue；优先队列PriorityQueue；后进先出LifoQueue类似于栈。 队列手绘 2.队列拥有的操作enqueue：入队（将元素插入队尾）dequeue：出队（将元素从队头删除）first：返回最先入队的元素（队列最前面的元素）3.单链表实现队列队列如果像栈那样用list类来实现的话会浪费很多的空间，如果重新排布位置就会消耗很多的时间划不来，就不具体实现了。用单链表实现队列的时候必须使用带尾指针的单链表，不然出栈操作需要遍历整个链表，时间复杂度会达到O（n），用了带尾指针的单链表后，直接用尾指针操作，时间复杂度O（1）。123456789101112131415161718192021222324252627282930313233343536373839404142class Queue: \"\"\"First In First Out\"\"\" class _Node: __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next=next def __init__(self): self._head=None #=_Node(None,None) self._tail=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def first(self): if self.isEmpty(): raise Exception('Queue is empty') return self._head._element def dequeue(self): if self.isEmpty(): raise Exception('Queue is empty') deleted_elem=self._head._element self._head=self._head._next self._size-=1 if self.isEmpty(): self._tail=None return deleted_elem def enqueue(self,element): new_element=self._Node(element,None) if self.isEmpty(): self._head=new_element #_head._element=new_element else: self._tail._next=new_element self._tail=new_element self._size+=1 时间复杂度时间复杂度分析 操作 时间复杂度 dequeue O（1） enqueue O（1） first O（1） isEmpty O（1） len O（1） 在python里如果使用list数组实现队列，弹出一个元素pop所用时间复杂度是非常高的，所以就不举list实现的例子了。当然，也可以使用numpy里的array或者collections里的array速度效率都是很可观的，读者可以自己去尝试一下。 队列的应用队列应用很多，也很常见，比如web服务器资源请求，打印机打印请求，CPU调度等等。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://blog.ojbkfeng.com/tags/队列/"}]},{"title":"Flask 依赖关系","slug":"python/Flask1","date":"2019-01-15T04:47:59.905Z","updated":"2019-01-18T04:35:24.754Z","comments":true,"path":"2019/01/15/python/Flask1/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/python/Flask1/","excerpt":"","text":"flask依赖关系Flask==1.0.2 click [required: &gt;=5.1, installed: 7.0] itsdangerous [required: &gt;=0.24, installed: 1.1.0] Jinja2 [required: &gt;=2.10, installed: 2.10] MarkupSafe [required: &gt;=0.23, installed: 1.1.0] Werkzeug [required: &gt;=0.14, installed: 0.14.1] click click是一个命令行工具，可以用很少的代码创建漂亮的命令行界面。可以自动生成格式化的帮助文件。详细功能见官方文档，或者我的后续文章。 itsdangerous 提供数字签名功能,防止命令被篡改，是一个安全工具。可以用来保证web请求的安全性。 Jinja2 Jinja2是一个现代的，设计师友好的Python模板语言，模仿Django的模板。使用可选的沙盒模板执行环境，它具有快速，广泛使用和安全性.官方文档 123456&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123; user.url &#125;&#125;\"&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; MarkupSafe 实现了一个转义字符的文本对象，因此可以安全地在HTML和XML中使用。替换具有特殊含义的字符，使其显示为实际字符。减轻了注入攻击，意味着可以安全地在页面上显示不受信任的用户输入。可以用来转义标签之类的。 Werkzeug Werkzeug是一个用于Python的WSGI实用程序库。主要用途是来启动wsgi，如果用Nginx的话，就用不上了，Nginx用的uwsgi。","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.ojbkfeng.com/categories/Web/"},{"name":"Flask","slug":"Web/Flask","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/"},{"name":"后端","slug":"Web/Flask/后端","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://blog.ojbkfeng.com/tags/flask/"}]},{"title":"虚拟环境管理：pipenv","slug":"python/pipenv","date":"2019-01-15T04:04:17.287Z","updated":"2019-01-17T05:30:11.080Z","comments":true,"path":"2019/01/15/python/pipenv/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/python/pipenv/","excerpt":"","text":"pipenvpipenv是一个虚拟环境管理工具。可选参数列表如下 options commands install123PS I:\\aproject&gt; pip install pipenv #安装PS I:\\aproject&gt; pipenv --version #版本pipenv, version 2018.11.26 创建、启动虚拟环境pipenv install #创建虚拟环境 pipenv shell #启动虚拟环境，如果该目录下没有，则创建并启动虚拟环境 虚拟环境、项目信息PS I:\\aproject&gt; pipenv --where #项目信息 I:\\aproject PS I:\\aproject&gt; pipenv --venv #虚拟环境信息 I:\\PyProjectEnv\\aproject-FX6vezy2 管理包pipenv install packagename #安装 pipenv install packagename #卸载 pipenv graph #查看已安装的包和依赖关系 如果需要了解更多请参阅pipenv","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ojbkfeng.com/categories/后端/"}],"tags":[{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://blog.ojbkfeng.com/tags/虚拟环境/"}]},{"title":"Python数据结构：栈及其应用","slug":"python/python数据结构栈","date":"2019-01-14T09:32:20.874Z","updated":"2019-01-17T04:14:44.692Z","comments":true,"path":"2019/01/14/python/python数据结构栈/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python/python数据结构栈/","excerpt":"","text":"1.什么是栈？栈：FILO（First In Last Out）的一种数据结构。详细介绍见维基百科定义 栈手绘图 栈拥有的操作1.pushpush操作是将元素扔进栈顶。 2.poppop操作将删除并返回栈顶的元素。 3.isEmpty如果栈里没有元素则返回True，如果有元素则返回False 4.top如果栈顶有元素，则返回栈顶元素，如果栈顶没有元素，则返回error，或null。 2.方法一：基于list类的栈基于list实现的栈要依赖Python的内置类list，依靠list本身的操作，加以限制操作的方式实现，这种实现方式最简单。 详细实现12345678910111213141516171819202122class ArrayStack: def __init__(self): self._data=[] def __len__(self): return len(_data) def isEmpty(self): return len(self._data)==0 def pop(self): if self.isEmpty(): raise Exception('stack is empty') return self._data.pop() def push(self,element): self._data.append(element) def top(self): if self._data.isEmpty(): raise Exception('stack is empty') return self._data[-1] 方法一时间复杂度分析使用list方法实现的时间复杂度都是常量级别的，时间复杂度上很大程度借了Python实内置函数现方式的光。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 3.方法二：单链表实现栈详细实现123456789101112131415161718192021222324252627282930313233343536class Stack: #Stack类 class _Node: #节点类 __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next =next def __init__(self): self._head=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def push(self,element): self._head=self._Node(element,self._head) self._size+=1 def pop(self): if self.isEmpty(): return False elem=self._head._element self._head=self._head._next self._size-=1 return elem def top(self): if self.isEmpty(): return False return self._head._element 方法二时间复杂度分析由于每次入栈出栈，都有一个_size累加累减，所以len的时间复杂度还是1。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 4.栈的应用 栈的应用范围还是很广的，比如我们常用的Ctrl + Z（撤销）就是基于栈的，每次返回上一次的操作，还有浏览器，文件管理器等等，总是记录上一次访问也面的地址，收到返回请求的时候直接返回栈顶的地址就行了，多次请求就不断地从栈顶返回就可以了。 括号匹配12345678910def checkValid(valid): stack=Stack() valid_dict=&#123;')':'(',']':'[','&#125;':'&#123;'&#125; for v in valid: if v not in valid_dict: #是否左括号 stack.push(v) #是左括号就入栈 elif stack.isEmpty() or valid_dict[v]!=stack.pop(): #有右括号，但栈为空或栈顶元素与右括号不匹配 return False return stack.isEmpty() #若全部匹配则栈为空返回True HTML标签匹配HTML匹配标签，可以在网页爬虫里用，写浏览器也需要吧。下面这个是简化的，只考虑&lt;&gt;&lt;/&gt;这种类型的标签对。find()函数，第一个参数：str 需要查找的字符串，第二个参数：index 起始位置。123456789101112131415161718def matched_html(html): stack=Stack() i=html.find('&lt;') #找到一个标签的‘&lt;’ while i!=-1: x=html.find('&gt;',i+1)#找到这个标签的‘&gt;’ if x==-1: #标签错误 return False tag=html[i+1:x] #获取标签&lt;tag&gt;中的标签名tag if not tag.startwith('/'): #判断有没有结束标签 stack.push(tag) else: if stack.isEmpty(): return False if tag[1:]!=stack.pop(): return False i=raw.find('&lt;',x+1) return stack.isEmpty()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://blog.ojbkfeng.com/tags/栈/"}]},{"title":"Python array 模块","slug":"python/python-array-module","date":"2019-01-14T08:07:24.447Z","updated":"2019-01-18T10:11:32.036Z","comments":true,"path":"2019/01/14/python/python-array-module/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python/python-array-module/","excerpt":"","text":"数组array 模块可以表示整数、浮点数、字符的数组。 初始化array(typecode,__initializer=…)typecode表示数组的类型,文章末尾有一个参数表包含所有支持类型以及内存占用情况initializer为初始化参数,是一个list、或者iterable、或是 bytes-like object1234567import array\"\"\"array_name = array.array(typecode, [initializers])\"\"\"arr=array.array('i',[1,2,3,4,5])# orarr1=array.array('i',[x for x in range(10)]) 支持的操作(官方文档)Array objects support the ordinary sequence operations of indexing(索引), slicing(切片), concatenation(拼接), and multiplication(乘法). 函数array.typecode（数据类型）The typecode character used to create the array.用于创建数组的typecode字符。 array.itemsize（单个数组元素大小）The length in bytes of(以字节为单位) one array item(数据项) in the internal(内部) representation(表示). 123456arr1 = array.array('i',[0,1,1,2,3])arr2 = array.array('i',[0,1,2,3])arr1.itemsize # 4arr2.itemsize # 4arr1.typecode # 'i'#相同的不占多余的空间 array.append(x)（添加元素）Append a new item(项) with value x to the end of the array. array.buffer_info() （返回一个元组：(存储数组的地址,元素的数量)）Return a tuple (address, length) giving the current(当前的) memory address(内存地址) and the length in elements of(在…的元素中) the buffer(缓冲区) used to hold array’s contents(内容). The size of the memory buffer(内存缓冲区) in bytes(以字节为单位) can be computed as(计算为) array.buffer_info()[1] * array.itemsize. This is occasionally(偶尔) useful when working with low-level (and inherently(本质上) unsafe) I/O interfaces(接口) that require memory addresses, such as certain(某些) ioctl() operations. The returned numbers are valid(有效) as long as(只要) the array exists and no length-changing(长度改变) operations are applied to it. Note When using array objects from code written in C or C++ (the only way to effectively(有效) make use of(有效利用) this information), it makes more sense(意义) to use the buffer interface supported by array objects. This method is maintained for backward compatibility(保持向后兼容) and should be avoided in new code. The buffer interface is documented in Buffer Protocol(缓冲区协议). 这个函数是为了保持向后兼容的，所以就不写解释了，翻译纯属为了熟悉英语。之后简单的，一看就懂的，或者基本用不上的，就只翻译了，或者看心情。 array.byteswap() “Byteswap” all items(项) of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised(引发). It is useful when reading data from a file written on a machine with a different byte order不同的字节序列. array.count(x)（统计个数） Return the number of occurrences of x(x发生的次数) in the array. array.extend(iterable)（扩展另一个array） Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array. 12345678arr1 = array.array('i',[i for i in range(10) if i%2==1]) #array('i', [1, 3, 5, 7, 9])arr2 = array.array('i',[i for i in range(10) if i%2==0]) #array('i', [0, 2, 4, 6, 8])#扩展相同type code的array对象arr1.extend(arr2)print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8])#扩展可迭代对象arr1.extend([i for i in range(100,110) if i%2==0])print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 100, 102, 104, 106, 108]) array.fromlist(list)123456arr2 = array.array('i',[0,99])l=[i for i in range(1000)]arr2.fromlist(l) #与下面for循环等价for i in l: #与上面fromlist等价 arr2.append(i) Append items from the list. This is equivalent to(相当于) for x in list: a.append(x) except that if there is a type error, the array is unchanged. array.index(x)（返回元素所在位置） Return the smallest i such that i is the index of the first occurrence of(出现) x in the array. array.insert(i, x) （将元素x插入到i前面） Insert a new item with value x in the array before position i. Negative(负) values are treated as(被视为) being relative(相对) to the end of the array. array.pop([i])（删除并返回一个元素） Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.默认是最后一个值 array.remove(x)（删除第一次出现的x） Remove the first occurrence of x from the array. array.reverse()（逆序） Reverse the order of the items in the array. array.tolist()（转换成list列表） Convert the array to an ordinary list with the same items. 操作元素示例12345678910import arrayarr1 = array.array('i',[i for i in range(10) if i%2==1])arr2 = array.array('i',[2,4,6,8,2])arr1.extend(arr2) #扩展print(arr1[0]) #第一个元素arr1[1]=5 #改变元素arr1.insert(1,60) #插入第二个位置print(arr2.index(6)) #6的位置 为2arr2.remove(2) #删除所有的2print(arr2) # array('i', [4, 6, 8]) type code 定义 Type code C Type Python Type Minimum size in bytes Notes ‘b’ signed char int 1 ‘B’ unsigned char int 1 ‘u’ Py_UNICODE Unicode character 2 (1) ‘h’ signed short int 2 ‘H’ unsigned short int 2 ‘i’ signed int int 2 ‘I’ unsigned int int 2 ‘l’ signed long int 4 ‘L’ unsigned long int 4 ‘q’ signed long long int 8 (2) ‘Q’ unsigned long long int 8 (2) ‘f’ float float 4 ‘d’ double float 8 (1)Py_UNICODE是typedef wchar_t，是16位或32位，取决于平台，已经被移除，官网不推荐使用。 (2).(官网原话)The ‘q’ and ‘Q’ type codes are available only if the platform C compiler used to build Python supports C long long, or, on Windows, __int64.只有当用于构建Python的平台C编译器支持C long long，或者在Windows上支持int64时，’q’和’Q’类型代码才可用。__","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"},{"name":"数据结构","slug":"Python/数据结构","permalink":"https://blog.ojbkfeng.com/categories/Python/数据结构/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://blog.ojbkfeng.com/tags/基础/"},{"name":"数组","slug":"数组","permalink":"https://blog.ojbkfeng.com/tags/数组/"}]}]}