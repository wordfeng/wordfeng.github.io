{"meta":{"title":"while(live){coding}","subtitle":"一个有味道的博客","description":"描述","author":"Xiao YuFeng","url":"https://blog.ojbkfeng.com"},"pages":[{"title":"","date":"2019-01-14T08:00:42.528Z","updated":"2019-01-14T08:00:42.528Z","comments":true,"path":"404.html","permalink":"https://blog.ojbkfeng.com/404.html","excerpt":"","text":"404 not found 你要找的页面不翼而飞了！"},{"title":"","date":"2019-01-17T05:46:26.450Z","updated":"2019-01-17T05:46:26.450Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ojbkfeng.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-17T05:47:48.000Z","updated":"2019-01-17T05:48:06.265Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ojbkfeng.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask 依赖关系","slug":"Flask1","date":"2019-01-15T04:47:59.905Z","updated":"2019-01-17T04:14:50.839Z","comments":true,"path":"2019/01/15/Flask1/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/Flask1/","excerpt":"","text":"flask依赖关系Flask==1.0.2 click [required: &gt;=5.1, installed: 7.0] itsdangerous [required: &gt;=0.24, installed: 1.1.0] Jinja2 [required: &gt;=2.10, installed: 2.10] MarkupSafe [required: &gt;=0.23, installed: 1.1.0] Werkzeug [required: &gt;=0.14, installed: 0.14.1] click click是一个命令行工具，可以用很少的代码创建漂亮的命令行界面。可以自动生成格式化的帮助文件。详细功能见官方文档，或者我的后续文章。 itsdangerous 提供数字签名功能,防止命令被篡改，是一个安全工具。可以用来保证web请求的安全性。 Jinja2 Jinja2是一个现代的，设计师友好的Python模板语言，模仿Django的模板。使用可选的沙盒模板执行环境，它具有快速，广泛使用和安全性.官方文档 123456&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123; user.url &#125;&#125;\"&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; MarkupSafe 实现了一个转义字符的文本对象，因此可以安全地在HTML和XML中使用。替换具有特殊含义的字符，使其显示为实际字符。减轻了注入攻击，意味着可以安全地在页面上显示不受信任的用户输入。可以用来转义标签之类的。 Werkzeug Werkzeug是一个用于Python的WSGI实用程序库。主要用途是来启动wsgi，如果用Nginx的话，就用不上了，Nginx用的uwsgi。","categories":[{"name":"web","slug":"web","permalink":"https://blog.ojbkfeng.com/categories/web/"},{"name":"python","slug":"web/python","permalink":"https://blog.ojbkfeng.com/categories/web/python/"},{"name":"后端","slug":"web/python/后端","permalink":"https://blog.ojbkfeng.com/categories/web/python/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://blog.ojbkfeng.com/tags/flask/"}]},{"title":"虚拟环境管理：pipenv","slug":"pipenv","date":"2019-01-15T04:04:17.287Z","updated":"2019-01-17T05:30:11.080Z","comments":true,"path":"2019/01/15/pipenv/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/pipenv/","excerpt":"","text":"pipenvpipenv是一个虚拟环境管理工具。可选参数列表如下 options commands install123PS I:\\aproject&gt; pip install pipenv #安装PS I:\\aproject&gt; pipenv --version #版本pipenv, version 2018.11.26 创建、启动虚拟环境pipenv install #创建虚拟环境 pipenv shell #启动虚拟环境，如果该目录下没有，则创建并启动虚拟环境 虚拟环境、项目信息PS I:\\aproject&gt; pipenv --where #项目信息 I:\\aproject PS I:\\aproject&gt; pipenv --venv #虚拟环境信息 I:\\PyProjectEnv\\aproject-FX6vezy2 管理包pipenv install packagename #安装 pipenv install packagename #卸载 pipenv graph #查看已安装的包和依赖关系 如果需要了解更多请参阅pipenv","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ojbkfeng.com/categories/后端/"}],"tags":[{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://blog.ojbkfeng.com/tags/虚拟环境/"}]},{"title":"Python数据结构：栈及其应用","slug":"python数据结构栈","date":"2019-01-14T09:32:20.874Z","updated":"2019-01-17T04:14:44.692Z","comments":true,"path":"2019/01/14/python数据结构栈/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python数据结构栈/","excerpt":"","text":"1.什么是栈？栈：FILO（First In Last Out）的一种数据结构。详细介绍见维基百科定义 栈手绘图 栈拥有的操作1.pushpush操作是将元素扔进栈顶。 2.poppop操作将删除并返回栈顶的元素。 3.isEmpty如果栈里没有元素则返回True，如果有元素则返回False 4.top如果栈顶有元素，则返回栈顶元素，如果栈顶没有元素，则返回error，或null。 2.方法一：基于list类的栈基于list实现的栈要依赖Python的内置类list，依靠list本身的操作，加以限制操作的方式实现，这种实现方式最简单。 详细实现12345678910111213141516171819202122class ArrayStack: def __init__(self): self._data=[] def __len__(self): return len(_data) def isEmpty(self): return len(self._data)==0 def pop(self): if self.isEmpty(): raise Exception('stack is empty') return self._data.pop() def push(self,element): self._data.append(element) def top(self): if self._data.isEmpty(): raise Exception('stack is empty') return self._data[-1] 方法一时间复杂度分析使用list方法实现的时间复杂度都是常量级别的，时间复杂度上很大程度借了Python实内置函数现方式的光。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 3.方法二：单链表实现栈详细实现123456789101112131415161718192021222324252627282930313233343536class Stack: #Stack类 class _Node: #节点类 __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next =next def __init__(self): self._head=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def push(self,element): self._head=self._Node(element,self._head) self._size+=1 def pop(self): if self.isEmpty(): return False elem=self._head._element self._head=self._head._next self._size-=1 return elem def top(self): if self.isEmpty(): return False return self._head._element 方法二时间复杂度分析由于每次入栈出栈，都有一个_size累加累减，所以len的时间复杂度还是1。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 4.栈的应用 栈的应用范围还是很广的，比如我们常用的Ctrl + Z（撤销）就是基于栈的，每次返回上一次的操作，还有浏览器，文件管理器等等，总是记录上一次访问也面的地址，收到返回请求的时候直接返回栈顶的地址就行了，多次请求就不断地从栈顶返回就可以了。 括号匹配12345678910def checkValid(valid): stack=Stack() valid_dict=&#123;')':'(',']':'[','&#125;':'&#123;'&#125; for v in valid: if v not in valid_dict: #是否左括号 stack.push(v) #是左括号就入栈 elif stack.isEmpty() or valid_dict[v]!=stack.pop(): #有右括号，但栈为空或栈顶元素与右括号不匹配 return False return stack.isEmpty() #若全部匹配则栈为空返回True HTML标签匹配HTML匹配标签，可以在网页爬虫里用，写浏览器也需要吧。下面这个是简化的，只考虑&lt;&gt;&lt;/&gt;这种类型的标签对。find()函数，第一个参数：str 需要查找的字符串，第二个参数：index 起始位置。123456789101112131415161718def matched_html(html): stack=Stack() i=html.find('&lt;') #找到一个标签的‘&lt;’ while i!=-1: x=html.find('&gt;',i+1)#找到这个标签的‘&gt;’ if x==-1: #标签错误 return False tag=html[i+1:x] #获取标签&lt;tag&gt;中的标签名tag if not tag.startwith('/'): #判断有没有结束标签 stack.push(tag) else: if stack.isEmpty(): return False if tag[1:]!=stack.pop(): return False i=raw.find('&lt;',x+1) return stack.isEmpty()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://blog.ojbkfeng.com/tags/栈/"}]},{"title":"Python array 模块","slug":"python-array-module","date":"2019-01-14T08:07:24.447Z","updated":"2019-01-17T04:11:14.300Z","comments":true,"path":"2019/01/14/python-array-module/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python-array-module/","excerpt":"","text":"数组array 模块可以表示整数、浮点数、字符的数组。 初始化array(typecode,__initializer=…)typecode表示数组的类型,文章末尾有一个参数表包含所有支持类型以及内存占用情况initializer为初始化参数,是一个list、或者iterable、或是 bytes-like object1234567import array\"\"\"array_name = array.array(typecode, [initializers])\"\"\"arr=array.array('i',[1,2,3,4,5])# orarr1=array.array('i',[x for x in range(10)]) 支持的操作(官方文档)Array objects support the ordinary sequence operations of indexing(索引), slicing(切片), concatenation(拼接), and multiplication(乘法). 函数array.typecodeThe typecode character used to create the array. 用于创建数组的typecode字符。 array.itemsizeThe length in bytes of(以字节为单位) one array item(数据项) in the internal(内部) representation(表示). 123456arr1 = array.array('i',[0,1,1,2,3])arr2 = array.array('i',[0,1,2,3])arr1.itemsize # 4arr2.itemsize # 4arr1.typecode # 'i'#相同的不占多余的空间 array.append(x)Append a new item(项) with value x to the end of the array. array.buffer_info() Return a tuple (address, length) giving the current(当前的) memory address(内存地址) and the length in elements of(在…的元素中) the buffer(缓冲区) used to hold array’s contents(内容). The size of the memory buffer(内存缓冲区) in bytes(以字节为单位) can be computed as(计算为) array.buffer_info()[1] * array.itemsize. This is occasionally(偶尔) useful when working with low-level (and inherently(本质上) unsafe) I/O interfaces(接口) that require memory addresses, such as certain(某些) ioctl() operations. The returned numbers are valid(有效) as long as(只要) the array exists and no length-changing(长度改变) operations are applied to it. Note When using array objects from code written in C or C++ (the only way to effectively(有效) make use of(有效利用) this information), it makes more sense(意义) to use the buffer interface supported by array objects. This method is maintained for backward compatibility(保持向后兼容) and should be avoided in new code. The buffer interface is documented in Buffer Protocol(缓冲区协议). 这个函数是为了保持向后兼容的，所以就不写解释了，翻译纯属为了熟悉英语。之后简单的，一看就懂的，或者基本用不上的，就只翻译了，或者看心情。 array.byteswap() “Byteswap” all items(项) of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised(引发). It is useful when reading data from a file written on a machine with a different byte order不同的字节序列. array.count(x) Return the number of occurrences of x(x发生的次数) in the array. array.extend(iterable) Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array. 12345678arr1 = array.array('i',[i for i in range(10) if i%2==1]) #array('i', [1, 3, 5, 7, 9])arr2 = array.array('i',[i for i in range(10) if i%2==0]) #array('i', [0, 2, 4, 6, 8])#扩展相同type code的array对象arr1.extend(arr2)print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8])#扩展可迭代对象arr1.extend([i for i in range(100,110) if i%2==0])print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 100, 102, 104, 106, 108]) array.fromlist(list) Append items from the list. This is equivalent to(相当于) for x in list: a.append(x) except that if there is a type error, the array is unchanged. array.index(x) Return the smallest i such that i is the index of the first occurrence of(出现) x in the array. array.insert(i, x) Insert a new item with value x in the array before position i. Negative(负) values are treated as(被视为) being relative(相对) to the end of the array. array.pop([i]) Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.默认是最后一个值 array.remove(x) Remove the first occurrence of x from the array. array.reverse() Reverse the order of the items in the array. array.tolist()¶ Convert the array to an ordinary list with the same items. 操作元素示例12345678910import arrayarr1 = array.array('i',[i for i in range(10) if i%2==1])arr2 = array.array('i',[2,4,6,8,2])arr1.extend(arr2) #扩展print(arr1[0]) #第一个元素arr1[1]=5 #改变元素arr1.insert(1,60) #插入第二个位置print(arr2.index(6)) #6的位置 为2arr2.remove(2) #删除所有的2print(arr2) # array('i', [4, 6, 8]) type code 定义 Type code C Type Python Type Minimum size in bytes Notes ‘b’ signed char int 1 ‘B’ unsigned char int 1 ‘u’ Py_UNICODE Unicode character 2 (1) ‘h’ signed short int 2 ‘H’ unsigned short int 2 ‘i’ signed int int 2 ‘I’ unsigned int int 2 ‘l’ signed long int 4 ‘L’ unsigned long int 4 ‘q’ signed long long int 8 (2) ‘Q’ unsigned long long int 8 (2) ‘f’ float float 4 ‘d’ double float 8 (1)Py_UNICODE是typedef wchar_t，是16位或32位，取决于平台，已经被移除，官网不推荐使用。 (2).(官网原话)The ‘q’ and ‘Q’ type codes are available only if the platform C compiler used to build Python supports C long long, or, on Windows, __int64.只有当用于构建Python的平台C编译器支持C long long，或者在Windows上支持int64时，’q’和’Q’类型代码才可用。__","categories":[{"name":"python","slug":"python","permalink":"https://blog.ojbkfeng.com/categories/python/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://blog.ojbkfeng.com/tags/基础/"},{"name":"数组","slug":"数组","permalink":"https://blog.ojbkfeng.com/tags/数组/"}]}]}