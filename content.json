{"meta":{"title":"while(live){coding}","subtitle":"一个有味道的博客","description":"描述","author":"Xiao YuFeng","url":"https://blog.ojbkfeng.com"},"pages":[{"title":"","date":"2019-01-14T08:00:42.528Z","updated":"2019-01-14T08:00:42.528Z","comments":true,"path":"404.html","permalink":"https://blog.ojbkfeng.com/404.html","excerpt":"","text":"404 not found 你要找的页面不翼而飞了！"},{"title":"categories","date":"2019-01-17T05:47:48.000Z","updated":"2019-01-17T05:48:06.265Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ojbkfeng.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-17T05:46:26.450Z","updated":"2019-01-17T05:46:26.450Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ojbkfeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python mysqlclient模块连接MySQL","slug":"mysqlclient","date":"2019-01-17T09:07:18.267Z","updated":"2019-01-18T04:35:37.159Z","comments":true,"path":"2019/01/17/mysqlclient/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/mysqlclient/","excerpt":"","text":"1.所需库mysqlclient2.遇到问题2.1安装时出现错误：无法打开“mysql.h”2.1.1解决方案 1.这是我从Stack Overflow上找的几个回答综合在一起得出的最OK解决方案：2.所需要的文件：&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python：https://downloads.mysql.com/archives/c-python/&ensp;&ensp;&ensp;&ensp;编译好的whl文件：https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient.Then&ensp;&ensp;&ensp;&ensp;我下的是mysqlclient-1.3.13-cp36-cp36m-win_amd64.whl 和 mysql-connector-python-8.0.12-py3.6-windows-x86-64bit.msi 版本&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python的安装会一闪而过 安装好后有两个新的包 安装好后会遇到mysql-connector-python 8.0.12 requires protobuf&gt;=3.0.0, which is not installed.直接安装protobuf即可，不安装也不影响根据需求而定 3.mysqlclient 官方GitHub主页4.使用portable的接口MySQLdb 连接的构造函数connect(arg,\\*args)必填参数(host，user，passwd，db，port,)对应参数(主机名称，用户名，密码，数据库名，mysqlserver的tcp端口，)其他参考官方主页或源代码123456789101112131415161718192021import MySQLdb #千万注意大小写#获取连接,传入参数错误或连接远程主机断开等会抛出异常try: conn = MySQLdb.connect( host = \"localhost\", #或127.0.0.1 port = 3306, #mysql默认端口3306 user = \"root\", #用户名 passwd = \"feng\", #密码 db = \"flask_obj\", #数据库名称 charset = \"utf8\" #数据库编码)cursor = conn.cursor() #创建游标cursor.execute('select * from `test` ') #传入查询语句result=cursor.fetchone() #查找一条数据，返回tupleprint(result) # (1, '2')cursor.close() #关闭游标conn.close() #关闭连接except MySQLdb.Error as e: print(\"Error: %s\" % e)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ojbkfeng.com/tags/MySQL/"},{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/tags/Python/"}]},{"title":"markdown从基础到癫疯","slug":"markdown语法","date":"2019-01-17T09:04:56.047Z","updated":"2019-01-17T10:54:44.275Z","comments":true,"path":"2019/01/17/markdown语法/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/markdown语法/","excerpt":"","text":"1.标题# 空格 标题 一级标题二级标题………. 六级标题# 一级标题 ## 二级标题 .......... ###### 六级标题 2.字体2.1加粗需要加粗的字前后分别用两个*包含起来 **加粗** 加粗 2.2斜体加粗跟加粗类似，前后用三个*包含起来 ***斜体加粗内容*** 斜体加粗字 2.3斜体斜体前后分别用一个*包含加来 *斜体* 斜体 2.4删除线前后分别两个~ ~~删除线~~ 删除线 3.引用使用&gt;符号表示在&gt;后面书写内容，可以使用连续的&gt;添加多级引用，感觉没什么卵用 &gt;我是引用 &gt;&gt;我是嵌套引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我是引引引引引引引引引用 我是引用 我是嵌套引用 我是引引引引引引引引引用 4.分割线用三个以上下列符号就行了，不建议使用三个组，如***有可能跟加粗斜体冲突 --- ---- *** ***** 5.图片![图片下显示的字](图片地址) 示例： ![sogou上的表情包](http://img02.sogoucdn.com/app/a/100520021/AB4384FE85BE242D5AF8607534289248) 效果如下： sogou上的表情包 6.超链接[超链接名](超链接地址) 跟图片的区别就是少了个！ [lz的主页](https://blog.ojbkfeng.cn) lz的主页 7.列表无序列表用下面任意一种就行,可以嵌套，可以跟有序列表混合嵌套。 - 列表内容 - 嵌套列表 + 列表内容 * 列表内容 列表内容 嵌套列表 列表内容 列表内容 有序列表 直接用数字序列替代前面的符号即可。 8.表格 |姓名|技能|排行| |:–|:–:|–:| 这一行分别是左对齐，居中，右对齐 |张三|吃屎|老三| |张二|喝尿|老二| |张大|张三张二会的他都会|老三| 姓名 技能 排行 张三 吃屎 老三 张二 喝尿 老二 张大 张三张二会的他都会 老三 9.代码块单行代码前后一个`反引号。 `list = [x for i in range(1,100000,2)]` list = [x for i in range(1,100000,2)] 多行代码前后用三个反引号`，前面三个反引号后面要加代码名，比如c 比如python 反引号反引号反引号pythonl = [x for i in range(1,100000,2)]print(l)反引号反引号反引号12l = [x for i in range(1,100000,2)]print(l) 10.流程图我这个是GitHub存储的，GitHub不支持流程图，模板用的hexo，默认也不支持流程图，但是hexo可以用插件强行支持。npm install --save hexo-filter-flowchart 反引号反引号反引号(由于渲染问题，我就用这个代替三个`了)flow —-定义部分格式： 变量名=&gt;模块名: 内容—- st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end —-流程控制部分格式：变量-&gt;变量—- st-&gt;op-&gt;cond cond(yes)-&gt;e —cond(yes)表示判断为yes执行的路线 cond(no)-&gt;op 反引号反引号反引号 操作模块 说明 start 开始 end 结束 opration 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 st=>start: 开始 op=>operation: Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"markdown","slug":"markdown","permalink":"https://blog.ojbkfeng.com/categories/markdown/"}],"tags":[{"name":"markdown基础","slug":"markdown基础","permalink":"https://blog.ojbkfeng.com/tags/markdown基础/"}]},{"title":"Ubuntu 16.04更新pip版本后无法使用","slug":"Ubuntu_pip_updata","date":"2019-01-17T08:56:20.422Z","updated":"2019-01-18T04:25:11.463Z","comments":true,"path":"2019/01/17/Ubuntu_pip_updata/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/Ubuntu_pip_updata/","excerpt":"","text":"1.首先卸载掉之前的pip sudo apt-get remove python-pip （卸载python2的pip）sudo apt-get remove python3-pip （卸载3版本的pip3） 2.安装pip sudo apt-get install python3-pip (安装python3） 3.可能遇到的问题 #####如果安装遇到更新apt-get问题 image.png apt-get update （更新代码） #####更新完毕后使用下列代码重新安装pip sudo apt-get install python3-pip （python3的pip）sudo apt-get install python-pip （python2的pip） #####遇到如下kernel版本问题，直接回车OK会自动更新至支持libc6的对应版本内核 image.png 更新完毕后会自动安装pip，此时输入安装pip代码（ sudo apt-get install python3-pip）会提示已安装 image.png 输入pip/pip3 -v 查看pip版本，pip回退成功！ pip3 -Vpip -V image.png","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://blog.ojbkfeng.com/tags/pip/"}]},{"title":"Python数据结构：队列及其应用","slug":"队列","date":"2019-01-17T08:44:35.355Z","updated":"2019-01-18T04:25:14.224Z","comments":true,"path":"2019/01/17/队列/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/队列/","excerpt":"","text":"1.什么是队列？队列是一种遵循先进先出的原则（First In First Out）d的数据结构。Python标准库里就有Queue类，标准库导入方法import queue 。 标准库中的queue标准库中的queue是线程安全的，并且使用了协程。 基于线程锁的asyncio Queue；优先队列PriorityQueue；后进先出LifoQueue类似于栈。 队列手绘 2.队列拥有的操作enqueue：入队（将元素插入队尾）dequeue：出队（将元素从队头删除）first：返回最先入队的元素（队列最前面的元素）3.单链表实现队列队列如果像栈那样用list类来实现的话会浪费很多的空间，如果重新排布位置就会消耗很多的时间划不来，就不具体实现了。用单链表实现队列的时候必须使用带尾指针的单链表，不然出栈操作需要遍历整个链表，时间复杂度会达到O（n），用了带尾指针的单链表后，直接用尾指针操作，时间复杂度O（1）。123456789101112131415161718192021222324252627282930313233343536373839404142class Queue: \"\"\"First In First Out\"\"\" class _Node: __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next=next def __init__(self): self._head=None #=_Node(None,None) self._tail=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def first(self): if self.isEmpty(): raise Exception('Queue is empty') return self._head._element def dequeue(self): if self.isEmpty(): raise Exception('Queue is empty') deleted_elem=self._head._element self._head=self._head._next self._size-=1 if self.isEmpty(): self._tail=None return deleted_elem def enqueue(self,element): new_element=self._Node(element,None) if self.isEmpty(): self._head=new_element #_head._element=new_element else: self._tail._next=new_element self._tail=new_element self._size+=1 时间复杂度时间复杂度分析 操作 时间复杂度 dequeue O（1） enqueue O（1） first O（1） isEmpty O（1） len O（1） 在python里如果使用list数组实现队列，弹出一个元素pop所用时间复杂度是非常高的，所以就不举list实现的例子了。当然，也可以使用numpy里的array或者collections里的array速度效率都是很可观的，读者可以自己去尝试一下。 队列的应用队列应用很多，也很常见，比如web服务器资源请求，打印机打印请求，CPU调度等等。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://blog.ojbkfeng.com/tags/队列/"}]},{"title":"Flask 依赖关系","slug":"Flask1","date":"2019-01-15T04:47:59.905Z","updated":"2019-01-18T04:35:24.754Z","comments":true,"path":"2019/01/15/Flask1/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/Flask1/","excerpt":"","text":"flask依赖关系Flask==1.0.2 click [required: &gt;=5.1, installed: 7.0] itsdangerous [required: &gt;=0.24, installed: 1.1.0] Jinja2 [required: &gt;=2.10, installed: 2.10] MarkupSafe [required: &gt;=0.23, installed: 1.1.0] Werkzeug [required: &gt;=0.14, installed: 0.14.1] click click是一个命令行工具，可以用很少的代码创建漂亮的命令行界面。可以自动生成格式化的帮助文件。详细功能见官方文档，或者我的后续文章。 itsdangerous 提供数字签名功能,防止命令被篡改，是一个安全工具。可以用来保证web请求的安全性。 Jinja2 Jinja2是一个现代的，设计师友好的Python模板语言，模仿Django的模板。使用可选的沙盒模板执行环境，它具有快速，广泛使用和安全性.官方文档 123456&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123; user.url &#125;&#125;\"&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; MarkupSafe 实现了一个转义字符的文本对象，因此可以安全地在HTML和XML中使用。替换具有特殊含义的字符，使其显示为实际字符。减轻了注入攻击，意味着可以安全地在页面上显示不受信任的用户输入。可以用来转义标签之类的。 Werkzeug Werkzeug是一个用于Python的WSGI实用程序库。主要用途是来启动wsgi，如果用Nginx的话，就用不上了，Nginx用的uwsgi。","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.ojbkfeng.com/categories/Web/"},{"name":"Flask","slug":"Web/Flask","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/"},{"name":"后端","slug":"Web/Flask/后端","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://blog.ojbkfeng.com/tags/flask/"}]},{"title":"虚拟环境管理：pipenv","slug":"pipenv","date":"2019-01-15T04:04:17.287Z","updated":"2019-01-17T05:30:11.080Z","comments":true,"path":"2019/01/15/pipenv/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/pipenv/","excerpt":"","text":"pipenvpipenv是一个虚拟环境管理工具。可选参数列表如下 options commands install123PS I:\\aproject&gt; pip install pipenv #安装PS I:\\aproject&gt; pipenv --version #版本pipenv, version 2018.11.26 创建、启动虚拟环境pipenv install #创建虚拟环境 pipenv shell #启动虚拟环境，如果该目录下没有，则创建并启动虚拟环境 虚拟环境、项目信息PS I:\\aproject&gt; pipenv --where #项目信息 I:\\aproject PS I:\\aproject&gt; pipenv --venv #虚拟环境信息 I:\\PyProjectEnv\\aproject-FX6vezy2 管理包pipenv install packagename #安装 pipenv install packagename #卸载 pipenv graph #查看已安装的包和依赖关系 如果需要了解更多请参阅pipenv","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ojbkfeng.com/categories/后端/"}],"tags":[{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://blog.ojbkfeng.com/tags/虚拟环境/"}]},{"title":"Python数据结构：栈及其应用","slug":"python数据结构栈","date":"2019-01-14T09:32:20.874Z","updated":"2019-01-17T04:14:44.692Z","comments":true,"path":"2019/01/14/python数据结构栈/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python数据结构栈/","excerpt":"","text":"1.什么是栈？栈：FILO（First In Last Out）的一种数据结构。详细介绍见维基百科定义 栈手绘图 栈拥有的操作1.pushpush操作是将元素扔进栈顶。 2.poppop操作将删除并返回栈顶的元素。 3.isEmpty如果栈里没有元素则返回True，如果有元素则返回False 4.top如果栈顶有元素，则返回栈顶元素，如果栈顶没有元素，则返回error，或null。 2.方法一：基于list类的栈基于list实现的栈要依赖Python的内置类list，依靠list本身的操作，加以限制操作的方式实现，这种实现方式最简单。 详细实现12345678910111213141516171819202122class ArrayStack: def __init__(self): self._data=[] def __len__(self): return len(_data) def isEmpty(self): return len(self._data)==0 def pop(self): if self.isEmpty(): raise Exception('stack is empty') return self._data.pop() def push(self,element): self._data.append(element) def top(self): if self._data.isEmpty(): raise Exception('stack is empty') return self._data[-1] 方法一时间复杂度分析使用list方法实现的时间复杂度都是常量级别的，时间复杂度上很大程度借了Python实内置函数现方式的光。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 3.方法二：单链表实现栈详细实现123456789101112131415161718192021222324252627282930313233343536class Stack: #Stack类 class _Node: #节点类 __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next =next def __init__(self): self._head=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def push(self,element): self._head=self._Node(element,self._head) self._size+=1 def pop(self): if self.isEmpty(): return False elem=self._head._element self._head=self._head._next self._size-=1 return elem def top(self): if self.isEmpty(): return False return self._head._element 方法二时间复杂度分析由于每次入栈出栈，都有一个_size累加累减，所以len的时间复杂度还是1。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 4.栈的应用 栈的应用范围还是很广的，比如我们常用的Ctrl + Z（撤销）就是基于栈的，每次返回上一次的操作，还有浏览器，文件管理器等等，总是记录上一次访问也面的地址，收到返回请求的时候直接返回栈顶的地址就行了，多次请求就不断地从栈顶返回就可以了。 括号匹配12345678910def checkValid(valid): stack=Stack() valid_dict=&#123;')':'(',']':'[','&#125;':'&#123;'&#125; for v in valid: if v not in valid_dict: #是否左括号 stack.push(v) #是左括号就入栈 elif stack.isEmpty() or valid_dict[v]!=stack.pop(): #有右括号，但栈为空或栈顶元素与右括号不匹配 return False return stack.isEmpty() #若全部匹配则栈为空返回True HTML标签匹配HTML匹配标签，可以在网页爬虫里用，写浏览器也需要吧。下面这个是简化的，只考虑&lt;&gt;&lt;/&gt;这种类型的标签对。find()函数，第一个参数：str 需要查找的字符串，第二个参数：index 起始位置。123456789101112131415161718def matched_html(html): stack=Stack() i=html.find('&lt;') #找到一个标签的‘&lt;’ while i!=-1: x=html.find('&gt;',i+1)#找到这个标签的‘&gt;’ if x==-1: #标签错误 return False tag=html[i+1:x] #获取标签&lt;tag&gt;中的标签名tag if not tag.startwith('/'): #判断有没有结束标签 stack.push(tag) else: if stack.isEmpty(): return False if tag[1:]!=stack.pop(): return False i=raw.find('&lt;',x+1) return stack.isEmpty()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://blog.ojbkfeng.com/tags/栈/"}]},{"title":"Python array 模块","slug":"python-array-module","date":"2019-01-14T08:07:24.447Z","updated":"2019-01-18T10:11:32.036Z","comments":true,"path":"2019/01/14/python-array-module/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python-array-module/","excerpt":"","text":"数组array 模块可以表示整数、浮点数、字符的数组。 初始化array(typecode,__initializer=…)typecode表示数组的类型,文章末尾有一个参数表包含所有支持类型以及内存占用情况initializer为初始化参数,是一个list、或者iterable、或是 bytes-like object1234567import array\"\"\"array_name = array.array(typecode, [initializers])\"\"\"arr=array.array('i',[1,2,3,4,5])# orarr1=array.array('i',[x for x in range(10)]) 支持的操作(官方文档)Array objects support the ordinary sequence operations of indexing(索引), slicing(切片), concatenation(拼接), and multiplication(乘法). 函数array.typecode（数据类型）The typecode character used to create the array.用于创建数组的typecode字符。 array.itemsize（单个数组元素大小）The length in bytes of(以字节为单位) one array item(数据项) in the internal(内部) representation(表示). 123456arr1 = array.array('i',[0,1,1,2,3])arr2 = array.array('i',[0,1,2,3])arr1.itemsize # 4arr2.itemsize # 4arr1.typecode # 'i'#相同的不占多余的空间 array.append(x)（添加元素）Append a new item(项) with value x to the end of the array. array.buffer_info() （返回一个元组：(存储数组的地址,元素的数量)）Return a tuple (address, length) giving the current(当前的) memory address(内存地址) and the length in elements of(在…的元素中) the buffer(缓冲区) used to hold array’s contents(内容). The size of the memory buffer(内存缓冲区) in bytes(以字节为单位) can be computed as(计算为) array.buffer_info()[1] * array.itemsize. This is occasionally(偶尔) useful when working with low-level (and inherently(本质上) unsafe) I/O interfaces(接口) that require memory addresses, such as certain(某些) ioctl() operations. The returned numbers are valid(有效) as long as(只要) the array exists and no length-changing(长度改变) operations are applied to it. Note When using array objects from code written in C or C++ (the only way to effectively(有效) make use of(有效利用) this information), it makes more sense(意义) to use the buffer interface supported by array objects. This method is maintained for backward compatibility(保持向后兼容) and should be avoided in new code. The buffer interface is documented in Buffer Protocol(缓冲区协议). 这个函数是为了保持向后兼容的，所以就不写解释了，翻译纯属为了熟悉英语。之后简单的，一看就懂的，或者基本用不上的，就只翻译了，或者看心情。 array.byteswap() “Byteswap” all items(项) of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised(引发). It is useful when reading data from a file written on a machine with a different byte order不同的字节序列. array.count(x)（统计个数） Return the number of occurrences of x(x发生的次数) in the array. array.extend(iterable)（扩展另一个array） Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array. 12345678arr1 = array.array('i',[i for i in range(10) if i%2==1]) #array('i', [1, 3, 5, 7, 9])arr2 = array.array('i',[i for i in range(10) if i%2==0]) #array('i', [0, 2, 4, 6, 8])#扩展相同type code的array对象arr1.extend(arr2)print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8])#扩展可迭代对象arr1.extend([i for i in range(100,110) if i%2==0])print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 100, 102, 104, 106, 108]) array.fromlist(list)123456arr2 = array.array('i',[0,99])l=[i for i in range(1000)]arr2.fromlist(l) #与下面for循环等价for i in l: #与上面fromlist等价 arr2.append(i) Append items from the list. This is equivalent to(相当于) for x in list: a.append(x) except that if there is a type error, the array is unchanged. array.index(x)（返回元素所在位置） Return the smallest i such that i is the index of the first occurrence of(出现) x in the array. array.insert(i, x) （将元素x插入到i前面） Insert a new item with value x in the array before position i. Negative(负) values are treated as(被视为) being relative(相对) to the end of the array. array.pop([i])（删除并返回一个元素） Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.默认是最后一个值 array.remove(x)（删除第一次出现的x） Remove the first occurrence of x from the array. array.reverse()（逆序） Reverse the order of the items in the array. array.tolist()（转换成list列表） Convert the array to an ordinary list with the same items. 操作元素示例12345678910import arrayarr1 = array.array('i',[i for i in range(10) if i%2==1])arr2 = array.array('i',[2,4,6,8,2])arr1.extend(arr2) #扩展print(arr1[0]) #第一个元素arr1[1]=5 #改变元素arr1.insert(1,60) #插入第二个位置print(arr2.index(6)) #6的位置 为2arr2.remove(2) #删除所有的2print(arr2) # array('i', [4, 6, 8]) type code 定义 Type code C Type Python Type Minimum size in bytes Notes ‘b’ signed char int 1 ‘B’ unsigned char int 1 ‘u’ Py_UNICODE Unicode character 2 (1) ‘h’ signed short int 2 ‘H’ unsigned short int 2 ‘i’ signed int int 2 ‘I’ unsigned int int 2 ‘l’ signed long int 4 ‘L’ unsigned long int 4 ‘q’ signed long long int 8 (2) ‘Q’ unsigned long long int 8 (2) ‘f’ float float 4 ‘d’ double float 8 (1)Py_UNICODE是typedef wchar_t，是16位或32位，取决于平台，已经被移除，官网不推荐使用。 (2).(官网原话)The ‘q’ and ‘Q’ type codes are available only if the platform C compiler used to build Python supports C long long, or, on Windows, __int64.只有当用于构建Python的平台C编译器支持C long long，或者在Windows上支持int64时，’q’和’Q’类型代码才可用。__","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"},{"name":"数据结构","slug":"Python/数据结构","permalink":"https://blog.ojbkfeng.com/categories/Python/数据结构/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://blog.ojbkfeng.com/tags/基础/"},{"name":"数组","slug":"数组","permalink":"https://blog.ojbkfeng.com/tags/数组/"}]}]}