{"meta":{"title":"while(live){coding}","subtitle":"一个有味道的博客","description":"描述","author":"Xiao YuFeng","url":"https://blog.ojbkfeng.com"},"pages":[{"title":"","date":"2019-02-24T15:11:13.887Z","updated":"2019-01-14T08:00:42.528Z","comments":true,"path":"404.html","permalink":"https://blog.ojbkfeng.com/404.html","excerpt":"","text":"404 not found 你要找的页面不翼而飞了！"},{"title":"categories","date":"2019-01-17T05:47:48.000Z","updated":"2019-01-17T05:48:06.265Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ojbkfeng.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-24T15:11:13.898Z","updated":"2019-01-17T05:46:26.450Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ojbkfeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"adb command","slug":"Android/adb","date":"2019-03-06T11:01:24.335Z","updated":"2019-03-07T06:15:31.898Z","comments":true,"path":"2019/03/06/Android/adb/","link":"","permalink":"https://blog.ojbkfeng.com/2019/03/06/Android/adb/","excerpt":"","text":"1. Debuggingadb devicesadb start-serveradb kill-server2. Package Manageradb install app.apkadb uninstall adb uninstall com.zhihu.android adb shell pm list packagesprint all package -f 查看文件关联 -d (disabled)查看已禁用的包 -e (enabled)已启用的包 -s 系统包 -3 第三方包 -i 查看已安装的包 -u 所有包，包括已卸载的包 –user &lt;USER_ID&gt; The user space to query.用户空间的包。adb shell pm path adb shell pm path com.zhihu.androidPrint the path to the APK of the given .打印指定包的apk路径。adb shell pm clear adb shell pm path com.zhihu.android清除数据和缓存。 3. File Manageradb pull [local] adb push filename.ext /target-path adb pull /target-file-path/filename.ext /target-path 3. adb shell（Android Terminal）4. adb wait-for-deviceblock until device is online. 6. Networkadb shell netstat7. Screen oprationadb shell screencap8. Logcatadb logcat","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.ojbkfeng.com/categories/Android/"}],"tags":[{"name":"debug tools","slug":"debug-tools","permalink":"https://blog.ojbkfeng.com/tags/debug-tools/"}]},{"title":"class, object, type之间的关系","slug":"python/class,type,object","date":"2019-02-27T01:22:56.423Z","updated":"2019-03-06T11:03:04.252Z","comments":true,"path":"2019/02/27/python/class,type,object/","link":"","permalink":"https://blog.ojbkfeng.com/2019/02/27/python/class,type,object/","excerpt":"","text":"类是type生成的对象1234567type(1) # inttype(int) # type#type -&gt; int -&gt; 1#type -&gt; class -&gt; objecttype.__bases__ # objecttype(object)object.__bases__ #() object是顶层基类type是一个类，也是一个对象","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[]},{"title":"在win上用Linux命令","slug":"cmd扩展Linuxbash命令","date":"2019-01-29T08:05:26.062Z","updated":"2019-01-29T08:23:08.149Z","comments":true,"path":"2019/01/29/cmd扩展Linuxbash命令/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/29/cmd扩展Linuxbash命令/","excerpt":"","text":"clink（记录命令）官网可以用来记录命令，cmd本身不带有这功能，关闭后，就不知道上次用了啥命令了。ctrl + r可以检索历史命令。 gow(支持Linux命令)github项目页(指不定啥时候就关了)随便安装在哪里，安装完成后打开cmd，输入ls，显示目录就OK了。Gow-0.8.0.exe GNU bash(解决gow的一些问题)下载页(指不定啥时候凉了)由于指不定啥时候就凉了所以我就下好保存起了。bash-203.zip只要用里面的ls.exe文件替代gow安装目录中的/bin目录下的ls.exe文件就可以解决无法显示中文的问题了。使用方式有一丢丢区别，gow的ls直接显示在cmd命令下，bash的显示方式不同，如果使用ls -l | less这种的话，按q退出。 需要用到的文件","categories":[{"name":"折腾永无止境","slug":"折腾永无止境","permalink":"https://blog.ojbkfeng.com/categories/折腾永无止境/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://blog.ojbkfeng.com/tags/bash/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.ojbkfeng.com/tags/cmd/"}]},{"title":"冒泡排序","slug":"算法_冒泡排序","date":"2019-01-29T06:11:52.401Z","updated":"2019-01-29T07:14:20.108Z","comments":true,"path":"2019/01/29/算法_冒泡排序/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/29/算法_冒泡排序/","excerpt":"","text":"维基百科 C++实现适用于整形和浮点型。12345678template&lt;typename T&gt;void bubble_sort(T arr[], int len) &#123;4int i, j;4for (i = 0; i &lt; len - 1; i++)44for (j = 0; j &lt; len - 1 - i; j++)444if (arr[j] &gt; arr[j + 1])4444std::swap(arr[j], arr[j + 1]);&#125; Python12345678def bubble_sort(iterable): sorting = list(iterable) length = len(sorting) for i in range(length -1): for j in range(length - 1, i, -1): if sorting[j] &lt; sorting[j - 1]: sorting[j], sorting[j - 1] = sorting[j - 1], sorting[j] return sorting JavaScript1234567891011Array.prototype.bubble_sort = function() &#123;4var i, j, temp;4for (i = 0; i &lt; this.length - 1; i++)44for (j = 0; j &lt; this.length - 1 - i; j++)444if (this[j] &gt; this[j + 1]) &#123;4444temp = this[j];4444this[j] = this[j + 1];4444this[j + 1] = temp;444&#125;4return this;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ojbkfeng.com/categories/算法/"}],"tags":[{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://blog.ojbkfeng.com/tags/冒泡排序/"}]},{"title":"Python re 模块","slug":"python re","date":"2019-01-26T06:13:24.145Z","updated":"2019-01-26T07:53:31.818Z","comments":true,"path":"2019/01/26/python re/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/26/python re/","excerpt":"","text":"1.函数表 函数 作用 match 在字符串起始位置匹配，如果没有匹配到返回None。 fullmatch 用表达式匹配所有字符串 search 匹配任意位置的字符串 sub 替换字符串中匹配成功项。 subn 同上，返回替换次数 split 把查找到的字符串分割，并且打包成列表返回 findall 匹配字符串中所有匹配的项，打包成列表返回 finditer 同上，但是返回的是迭代器 compile 编译正则表达式(pattern)，生成一个正则表达式对象(RegexObject)，仅供match()和search()函数使用。 purge 清除缓存 escape 除了ASCII字母，数字和以外，转义模式中的所有字符 2.可选标志 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，会影响 ^ 和 $ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。会标志影响 \\w, \\W, \\b, \\B. 3.re.match()在字符串开头匹配。函数原型：re.match(pattern, string, flags=0)匹配成功：返回匹配的对象匹配失败：返回None 参数 意义 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 可选标志位，用于控制正则表达式的匹配方式 12345678910# 在字符串开头匹配到返回一个对象print(re.match('blog', 'blog.ojbkfeng.cn'))# &lt;_sre.SRE_Match object; span=(0, 4), match='blog'&gt;# 在开头处没匹配到返回Noneprint(re.match('cn', 'blog.ojbkfeng.cn'))# Noneprint(re.match('blog', 'blog.ojbkfeng.cn').span())# (0, 4) 1234567891011strings = \"what the fuck ???\"reg = re.match(r'(.*) the (.*?) .*', strings, re.M|re.I)if reg: print(reg.group()) # what the fuck ??? print(reg.group(1)) # 匹配到的第一个 # what print(reg.group(2)) # 第二个 # fuckelse: print( \"No match!!\") 4.re.search()在整个字符串匹配，并返回成功的第一个。函数原型：re.search(pattern, string, flags=0)匹配成功：返回匹配的对象。匹配失败：返回None。参数同match(), 用法相同。 5.re.sub()替换字符串中匹配成功项。函数原型：re.sub(pattern, repl, string, count=0, flags=0) 参数 意义 pattern 正则中的模式字符串。 repl 替换的字符串，也可为一个函数。 string 要被查找替换的原始字符串。 count 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 123strings = \"188-7438-6478\"num = re.sub(r'\\D', \"\", strings)print(num) # 18874386478 6.re.compile()编译正则表达式(pattern)，生成一个正则表达式对象(RegexObject)，仅供match()和search()函数使用。函数原型：re.compile(pattern[, flags])pattern : 一个字符串形式的正则表达式flags : 可选标志，文章上面有参数表。1234strings = \"188-7438-6478\"reObj = re.compile(r'\\D')num = re.sub(reObj, \"\", strings)print(num) # 18874386478 7.re.split()按照能够匹配的子串将字符串分割后返回列表。函数原型re.split(pattern, string[, maxsplit=0, flags=0])maxsplit：分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数其余参数与match()相同。12re.split('\\W+', 'ojbk, ojbk, ojbkfeng.')# ['ojbk', 'ojbk', 'ojbkfeng', ''] 8.findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 跟match()和search()不同的是findall()匹配所有出现过的字符串，match和search只匹配一次。函数原型：findall(string[, pos[, endpos]]) 参数 意义 string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 9.re.finditer()跟findall()一样，区别是返回一个迭代器(iter)。函数原型：re.finditer(pattern, string, flags=0)","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/"},{"name":"Python","slug":"正则表达式/Python","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/Python/"}],"tags":[{"name":"Python内置模块","slug":"Python内置模块","permalink":"https://blog.ojbkfeng.com/tags/Python内置模块/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-01-26T04:45:50.932Z","updated":"2019-01-26T06:27:45.144Z","comments":true,"path":"2019/01/26/正则表达式/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/26/正则表达式/","excerpt":"","text":"特殊字符表Python re模块由于渲染问题下面表格的|使用I代替。 特殊字符 意义 示例 . 默认情况下匹配除了换行符以外的任何字符，在DOTALL模式下，可以匹配任意字符 a.c ^ (Caret)插入符，匹配起始位置的字符串，在MULTILINE模式下，可以在换行后继续匹配。 ^Hello $ 匹配结束的字符串，也可用MULTILINE模式 abc.$匹配abc1\\n * 匹配*前的字符0个或n个 ab*匹配’a’、’ab’、’a’或含有n个b的abbbb + 匹配一个或多个前面的字符。 a+匹配ab和aaab，但与a*和a?不同的是, 模式a+不会匹配开始处没有’a’的字符串. ? 使得到的RE匹配前面RE的0或1次重​​复。 ab?将匹配’a’或’ab’。 {m} 次数限定符，匹配出现对应次数的字符串。 a{2}匹配aa {m,n} 次数区间限定符，同上。左右都闭区间。 a{1,2}匹配ab中的‘a’，然而匹配aaaab就只能匹配到前面两个a。 \\ 转义字符，用来匹配特殊字符。 \\. [ ] ①表示一组字符；② ‘(‘, ‘+’, ‘*’, 或 ‘)’之类的特殊字符在[]里就失去意义了，只能表示字面意思。③^的意义改变成除……以外的其他字符 ①[0-9A-Za-z]表示匹配所有的字符和数字；②[abc]匹配’a’,’b’或’c’ ③ [^^]表示除了^以外的所有字符,[^a]除a以外 AIB 将一个或多个可选字符分隔开 grayIgrey匹配gray或grey,也可以写成gr(aIe)y (…) 确定求值顺序，(?...)特殊模式，不区分大小写和多行 (abc)+匹配abcabc666中的所有abc但不匹配ab或者bc等 \\A 只匹配开头的字符串 \\b 在字符串的开头或结尾匹配空字符串 \\B 匹配一个不再字符串开头或结尾的空字符串 \\d 匹配一个数字 \\D 匹配一个非数字 \\w 匹配Unicode字符,任何语言的字符，包括数字下划线 \\W 匹配不是单词字符的字符，相当于[^A-Za-z0-9_] \\s 对于Unicode字符，匹配空格，包括[ \\t\\n\\r\\f\\v]，对于8-bit字符串考虑有空格的字符 \\S 匹配不是空格的字符 贪婪模式*, +, ?, {min,max}默认情况下都是贪婪的(尽可能多匹配), 例如：&lt;.*&gt;匹配&lt;a&gt; b &lt;c&gt;会将整个字符串全部匹配。添加限定符？后将解除这个模式&lt;.*?&gt;将只匹配到&lt;a&gt;。a{3,5}?将只匹配aaaaaa中的前3个。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.ojbkfeng.com/tags/正则表达式/"}]},{"title":"cmd常用命令","slug":"cmd","date":"2019-01-25T14:16:19.906Z","updated":"2019-01-25T15:46:17.980Z","comments":true,"path":"2019/01/25/cmd/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/25/cmd/","excerpt":"","text":"官方文档 帮助命令+ /?显示帮助文档例如：taskkill /?arp /?help + 命令 显示帮助（不推荐使用）速度很慢，查找内容超级多。但是用来查看echo的帮助还是可以的，help echo，如果用echo /?的话是什么效果你可以试试。下面是在cmd里使用了帮助需要注意的： 符号 描述 没有括号或大括号的文本 必须显示输入的 &lt;尖括号内的文字&gt; 必须为其提供值的占位符 [方括号内的文字] 可选项目 {文字里面的大括号} 必要的参数; 选一个 垂直条（I） 互斥元素的分隔符; 选一个 省略号（…） 可以重复的项目 注：垂直条是|,由于用的markdown上面无法解析，所以用I替代了。 taskkill使用该工具按照进程 ID (PID) 或映像名称终止任务。 关闭PID号为3716和123的进程/F：强制taskkill /pid 3716 /pid 123 /F 关闭所有记事本taskkill /IM notepad.exe where（超实用）显示符合搜索模式的文件位置。在默认情况下，搜索是在当前目录和 PATH环境变量指定的路径中执行的。where gcc 显示gcc解释器的地址where /r c:\\ test 查找c盘里的名字是test的文件 whoamiwhoami 显示当前用户whoami /all 显示当前用户所有信息 cls（清空面板）defrag（磁盘整理）整理C盘并且显示进度和详细信息defrag C: /U /V echo（显示内容，便于debug）打印path信息：echo %PATH% find搜索文件或文件中的文本字符串，并显示包含指定字符串的文本行。 /V 显示所有未包含指定字符串的行。 /C 仅显示包含字符串的行数。 /N 显示行号。 /I 搜索字符串时忽略大小写。 /OFF[LINE] 不要跳过具有脱机属性集的文件。 “string” 指定要搜索的文本字符串。 [drive:][path]filename 指定要搜索的文件。 findstr在文件中寻找字符串。通常与其他命令搭配使用例如netstat -ano|findstr 5000查找端口号5000的进程详情见 findstr /? ipconfig&gt; ipconfig ... 显示信息 &gt; ipconfig /all ... 显示详细信息 &gt; ipconfig /renew ... 更新所有适配器 netstat显示协议统计信息和当前 TCP/IP 网络连接。常用组合：netstat -nb 显示所有活动连接(网络连接)。netstat -o 显示路由表 查找5000端口进程netstat -ano|findstr 5000 perfmon（性能监控）perfmon /RES ：显示资源监控，包括TCP连接、网络活动(网络IO)、网络活动的进程。 set（操作环境变量）显示、设置或删除 cmd.exe 环境变量。SET [variable=[string]] variable 指定环境变量名。 string 指定要指派给变量的一系列字符串。 tasklist（任务列表）ftp将文件传送到运行 FTP 服务器服务(经常称为后台程序)的计算机以及将文件从该计算机传出。可以交互使用 Ftp。 title 命令窗的标题title wtf？？ tree（显示文件结构）TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。例如：显示磁盘所有文件，|more是懒加载。tree c:\\ /f | more","categories":[{"name":"终端","slug":"终端","permalink":"https://blog.ojbkfeng.com/categories/终端/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://blog.ojbkfeng.com/tags/cmd/"}]},{"title":"Python mysqlclient模块连接MySQL","slug":"mysqlclient","date":"2019-01-17T09:07:18.267Z","updated":"2019-01-18T04:35:37.159Z","comments":true,"path":"2019/01/17/mysqlclient/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/mysqlclient/","excerpt":"","text":"1.所需库mysqlclient2.遇到问题2.1安装时出现错误：无法打开“mysql.h”2.1.1解决方案 1.这是我从Stack Overflow上找的几个回答综合在一起得出的最OK解决方案：2.所需要的文件：&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python：https://downloads.mysql.com/archives/c-python/&ensp;&ensp;&ensp;&ensp;编译好的whl文件：https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient.Then&ensp;&ensp;&ensp;&ensp;我下的是mysqlclient-1.3.13-cp36-cp36m-win_amd64.whl 和 mysql-connector-python-8.0.12-py3.6-windows-x86-64bit.msi 版本&ensp;&ensp;&ensp;&ensp;MySQL Connector / Python的安装会一闪而过 安装好后有两个新的包 安装好后会遇到mysql-connector-python 8.0.12 requires protobuf&gt;=3.0.0, which is not installed.直接安装protobuf即可，不安装也不影响根据需求而定 3.mysqlclient 官方GitHub主页4.使用portable的接口MySQLdb 连接的构造函数connect(arg,\\*args)必填参数(host，user，passwd，db，port,)对应参数(主机名称，用户名，密码，数据库名，mysqlserver的tcp端口，)其他参考官方主页或源代码123456789101112131415161718192021import MySQLdb #千万注意大小写#获取连接,传入参数错误或连接远程主机断开等会抛出异常try: conn = MySQLdb.connect( host = \"localhost\", #或127.0.0.1 port = 3306, #mysql默认端口3306 user = \"root\", #用户名 passwd = \"feng\", #密码 db = \"flask_obj\", #数据库名称 charset = \"utf8\" #数据库编码)cursor = conn.cursor() #创建游标cursor.execute('select * from `test` ') #传入查询语句result=cursor.fetchone() #查找一条数据，返回tupleprint(result) # (1, '2')cursor.close() #关闭游标conn.close() #关闭连接except MySQLdb.Error as e: print(\"Error: %s\" % e)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ojbkfeng.com/tags/MySQL/"},{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/tags/Python/"}]},{"title":"markdown从基础到癫疯","slug":"markdown语法","date":"2019-01-17T09:04:56.047Z","updated":"2019-01-17T10:54:44.275Z","comments":true,"path":"2019/01/17/markdown语法/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/markdown语法/","excerpt":"","text":"1.标题# 空格 标题 一级标题二级标题………. 六级标题# 一级标题 ## 二级标题 .......... ###### 六级标题 2.字体2.1加粗需要加粗的字前后分别用两个*包含起来 **加粗** 加粗 2.2斜体加粗跟加粗类似，前后用三个*包含起来 ***斜体加粗内容*** 斜体加粗字 2.3斜体斜体前后分别用一个*包含加来 *斜体* 斜体 2.4删除线前后分别两个~ ~~删除线~~ 删除线 3.引用使用&gt;符号表示在&gt;后面书写内容，可以使用连续的&gt;添加多级引用，感觉没什么卵用 &gt;我是引用 &gt;&gt;我是嵌套引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我是引引引引引引引引引用 我是引用 我是嵌套引用 我是引引引引引引引引引用 4.分割线用三个以上下列符号就行了，不建议使用三个组，如***有可能跟加粗斜体冲突 --- ---- *** ***** 5.图片![图片下显示的字](图片地址) 示例： ![sogou上的表情包](http://img02.sogoucdn.com/app/a/100520021/AB4384FE85BE242D5AF8607534289248) 效果如下： sogou上的表情包 6.超链接[超链接名](超链接地址) 跟图片的区别就是少了个！ [lz的主页](https://blog.ojbkfeng.cn) lz的主页 7.列表无序列表用下面任意一种就行,可以嵌套，可以跟有序列表混合嵌套。 - 列表内容 - 嵌套列表 + 列表内容 * 列表内容 列表内容 嵌套列表 列表内容 列表内容 有序列表 直接用数字序列替代前面的符号即可。 8.表格 |姓名|技能|排行| |:–|:–:|–:| 这一行分别是左对齐，居中，右对齐 |张三|吃屎|老三| |张二|喝尿|老二| |张大|张三张二会的他都会|老三| 姓名 技能 排行 张三 吃屎 老三 张二 喝尿 老二 张大 张三张二会的他都会 老三 9.代码块单行代码前后一个`反引号。 `list = [x for i in range(1,100000,2)]` list = [x for i in range(1,100000,2)] 多行代码前后用三个反引号`，前面三个反引号后面要加代码名，比如c 比如python 反引号反引号反引号pythonl = [x for i in range(1,100000,2)]print(l)反引号反引号反引号12l = [x for i in range(1,100000,2)]print(l) 10.流程图我这个是GitHub存储的，GitHub不支持流程图，模板用的hexo，默认也不支持流程图，但是hexo可以用插件强行支持。npm install --save hexo-filter-flowchart 反引号反引号反引号(由于渲染问题，我就用这个代替三个`了)flow —-定义部分格式： 变量名=&gt;模块名: 内容—- st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end —-流程控制部分格式：变量-&gt;变量—- st-&gt;op-&gt;cond cond(yes)-&gt;e —cond(yes)表示判断为yes执行的路线 cond(no)-&gt;op 反引号反引号反引号 操作模块 说明 start 开始 end 结束 opration 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 st=>start: 开始 op=>operation: Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"markdown","slug":"markdown","permalink":"https://blog.ojbkfeng.com/categories/markdown/"}],"tags":[{"name":"markdown基础","slug":"markdown基础","permalink":"https://blog.ojbkfeng.com/tags/markdown基础/"}]},{"title":"Ubuntu 16.04更新pip版本后无法使用","slug":"Ubuntu_pip_updata","date":"2019-01-17T08:56:20.422Z","updated":"2019-01-18T04:25:11.463Z","comments":true,"path":"2019/01/17/Ubuntu_pip_updata/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/Ubuntu_pip_updata/","excerpt":"","text":"1.首先卸载掉之前的pip sudo apt-get remove python-pip （卸载python2的pip）sudo apt-get remove python3-pip （卸载3版本的pip3） 2.安装pip sudo apt-get install python3-pip (安装python3） 3.可能遇到的问题 #####如果安装遇到更新apt-get问题 image.png apt-get update （更新代码） #####更新完毕后使用下列代码重新安装pip sudo apt-get install python3-pip （python3的pip）sudo apt-get install python-pip （python2的pip） #####遇到如下kernel版本问题，直接回车OK会自动更新至支持libc6的对应版本内核 image.png 更新完毕后会自动安装pip，此时输入安装pip代码（ sudo apt-get install python3-pip）会提示已安装 image.png 输入pip/pip3 -v 查看pip版本，pip回退成功！ pip3 -Vpip -V image.png","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://blog.ojbkfeng.com/tags/pip/"}]},{"title":"Python数据结构：队列及其应用","slug":"队列","date":"2019-01-17T08:44:35.355Z","updated":"2019-01-18T04:25:14.224Z","comments":true,"path":"2019/01/17/队列/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/17/队列/","excerpt":"","text":"1.什么是队列？队列是一种遵循先进先出的原则（First In First Out）d的数据结构。Python标准库里就有Queue类，标准库导入方法import queue 。 标准库中的queue标准库中的queue是线程安全的，并且使用了协程。 基于线程锁的asyncio Queue；优先队列PriorityQueue；后进先出LifoQueue类似于栈。 队列手绘 2.队列拥有的操作enqueue：入队（将元素插入队尾）dequeue：出队（将元素从队头删除）first：返回最先入队的元素（队列最前面的元素）3.单链表实现队列队列如果像栈那样用list类来实现的话会浪费很多的空间，如果重新排布位置就会消耗很多的时间划不来，就不具体实现了。用单链表实现队列的时候必须使用带尾指针的单链表，不然出栈操作需要遍历整个链表，时间复杂度会达到O（n），用了带尾指针的单链表后，直接用尾指针操作，时间复杂度O（1）。123456789101112131415161718192021222324252627282930313233343536373839404142class Queue: \"\"\"First In First Out\"\"\" class _Node: __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next=next def __init__(self): self._head=None #=_Node(None,None) self._tail=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def first(self): if self.isEmpty(): raise Exception('Queue is empty') return self._head._element def dequeue(self): if self.isEmpty(): raise Exception('Queue is empty') deleted_elem=self._head._element self._head=self._head._next self._size-=1 if self.isEmpty(): self._tail=None return deleted_elem def enqueue(self,element): new_element=self._Node(element,None) if self.isEmpty(): self._head=new_element #_head._element=new_element else: self._tail._next=new_element self._tail=new_element self._size+=1 时间复杂度时间复杂度分析 操作 时间复杂度 dequeue O（1） enqueue O（1） first O（1） isEmpty O（1） len O（1） 在python里如果使用list数组实现队列，弹出一个元素pop所用时间复杂度是非常高的，所以就不举list实现的例子了。当然，也可以使用numpy里的array或者collections里的array速度效率都是很可观的，读者可以自己去尝试一下。 队列的应用队列应用很多，也很常见，比如web服务器资源请求，打印机打印请求，CPU调度等等。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://blog.ojbkfeng.com/tags/队列/"}]},{"title":"Flask 依赖关系","slug":"Flask1","date":"2019-01-15T04:47:59.905Z","updated":"2019-01-18T04:35:24.754Z","comments":true,"path":"2019/01/15/Flask1/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/Flask1/","excerpt":"","text":"flask依赖关系Flask==1.0.2 click [required: &gt;=5.1, installed: 7.0] itsdangerous [required: &gt;=0.24, installed: 1.1.0] Jinja2 [required: &gt;=2.10, installed: 2.10] MarkupSafe [required: &gt;=0.23, installed: 1.1.0] Werkzeug [required: &gt;=0.14, installed: 0.14.1] click click是一个命令行工具，可以用很少的代码创建漂亮的命令行界面。可以自动生成格式化的帮助文件。详细功能见官方文档，或者我的后续文章。 itsdangerous 提供数字签名功能,防止命令被篡改，是一个安全工具。可以用来保证web请求的安全性。 Jinja2 Jinja2是一个现代的，设计师友好的Python模板语言，模仿Django的模板。使用可选的沙盒模板执行环境，它具有快速，广泛使用和安全性.官方文档 123456&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123; user.url &#125;&#125;\"&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; MarkupSafe 实现了一个转义字符的文本对象，因此可以安全地在HTML和XML中使用。替换具有特殊含义的字符，使其显示为实际字符。减轻了注入攻击，意味着可以安全地在页面上显示不受信任的用户输入。可以用来转义标签之类的。 Werkzeug Werkzeug是一个用于Python的WSGI实用程序库。主要用途是来启动wsgi，如果用Nginx的话，就用不上了，Nginx用的uwsgi。","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.ojbkfeng.com/categories/Web/"},{"name":"Flask","slug":"Web/Flask","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/"},{"name":"后端","slug":"Web/Flask/后端","permalink":"https://blog.ojbkfeng.com/categories/Web/Flask/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://blog.ojbkfeng.com/tags/flask/"}]},{"title":"虚拟环境管理：pipenv","slug":"pipenv","date":"2019-01-15T04:04:17.287Z","updated":"2019-01-17T05:30:11.080Z","comments":true,"path":"2019/01/15/pipenv/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/15/pipenv/","excerpt":"","text":"pipenvpipenv是一个虚拟环境管理工具。可选参数列表如下 options commands install123PS I:\\aproject&gt; pip install pipenv #安装PS I:\\aproject&gt; pipenv --version #版本pipenv, version 2018.11.26 创建、启动虚拟环境pipenv install #创建虚拟环境 pipenv shell #启动虚拟环境，如果该目录下没有，则创建并启动虚拟环境 虚拟环境、项目信息PS I:\\aproject&gt; pipenv --where #项目信息 I:\\aproject PS I:\\aproject&gt; pipenv --venv #虚拟环境信息 I:\\PyProjectEnv\\aproject-FX6vezy2 管理包pipenv install packagename #安装 pipenv install packagename #卸载 pipenv graph #查看已安装的包和依赖关系 如果需要了解更多请参阅pipenv","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.ojbkfeng.com/categories/后端/"}],"tags":[{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://blog.ojbkfeng.com/tags/虚拟环境/"}]},{"title":"Python数据结构：栈及其应用","slug":"python数据结构栈","date":"2019-01-14T09:32:20.874Z","updated":"2019-01-17T04:14:44.692Z","comments":true,"path":"2019/01/14/python数据结构栈/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python数据结构栈/","excerpt":"","text":"1.什么是栈？栈：FILO（First In Last Out）的一种数据结构。详细介绍见维基百科定义 栈手绘图 栈拥有的操作1.pushpush操作是将元素扔进栈顶。 2.poppop操作将删除并返回栈顶的元素。 3.isEmpty如果栈里没有元素则返回True，如果有元素则返回False 4.top如果栈顶有元素，则返回栈顶元素，如果栈顶没有元素，则返回error，或null。 2.方法一：基于list类的栈基于list实现的栈要依赖Python的内置类list，依靠list本身的操作，加以限制操作的方式实现，这种实现方式最简单。 详细实现12345678910111213141516171819202122class ArrayStack: def __init__(self): self._data=[] def __len__(self): return len(_data) def isEmpty(self): return len(self._data)==0 def pop(self): if self.isEmpty(): raise Exception('stack is empty') return self._data.pop() def push(self,element): self._data.append(element) def top(self): if self._data.isEmpty(): raise Exception('stack is empty') return self._data[-1] 方法一时间复杂度分析使用list方法实现的时间复杂度都是常量级别的，时间复杂度上很大程度借了Python实内置函数现方式的光。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 3.方法二：单链表实现栈详细实现123456789101112131415161718192021222324252627282930313233343536class Stack: #Stack类 class _Node: #节点类 __slots__='_element','_next' def __init__(self,element,next): self._element=element self._next =next def __init__(self): self._head=None self._size=0 def __len__(self): return self._size def isEmpty(self): return self._size==0 def push(self,element): self._head=self._Node(element,self._head) self._size+=1 def pop(self): if self.isEmpty(): return False elem=self._head._element self._head=self._head._next self._size-=1 return elem def top(self): if self.isEmpty(): return False return self._head._element 方法二时间复杂度分析由于每次入栈出栈，都有一个_size累加累减，所以len的时间复杂度还是1。 操作 时间复杂度 push O（1） pop O（1） top O（1） isEmpty O（1） len O（1） 4.栈的应用 栈的应用范围还是很广的，比如我们常用的Ctrl + Z（撤销）就是基于栈的，每次返回上一次的操作，还有浏览器，文件管理器等等，总是记录上一次访问也面的地址，收到返回请求的时候直接返回栈顶的地址就行了，多次请求就不断地从栈顶返回就可以了。 括号匹配12345678910def checkValid(valid): stack=Stack() valid_dict=&#123;')':'(',']':'[','&#125;':'&#123;'&#125; for v in valid: if v not in valid_dict: #是否左括号 stack.push(v) #是左括号就入栈 elif stack.isEmpty() or valid_dict[v]!=stack.pop(): #有右括号，但栈为空或栈顶元素与右括号不匹配 return False return stack.isEmpty() #若全部匹配则栈为空返回True HTML标签匹配HTML匹配标签，可以在网页爬虫里用，写浏览器也需要吧。下面这个是简化的，只考虑&lt;&gt;&lt;/&gt;这种类型的标签对。find()函数，第一个参数：str 需要查找的字符串，第二个参数：index 起始位置。123456789101112131415161718def matched_html(html): stack=Stack() i=html.find('&lt;') #找到一个标签的‘&lt;’ while i!=-1: x=html.find('&gt;',i+1)#找到这个标签的‘&gt;’ if x==-1: #标签错误 return False tag=html[i+1:x] #获取标签&lt;tag&gt;中的标签名tag if not tag.startwith('/'): #判断有没有结束标签 stack.push(tag) else: if stack.isEmpty(): return False if tag[1:]!=stack.pop(): return False i=raw.find('&lt;',x+1) return stack.isEmpty()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.ojbkfeng.com/categories/数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://blog.ojbkfeng.com/tags/栈/"}]},{"title":"Python array 模块","slug":"python-array-module","date":"2019-01-14T08:07:24.447Z","updated":"2019-01-18T10:11:32.036Z","comments":true,"path":"2019/01/14/python-array-module/","link":"","permalink":"https://blog.ojbkfeng.com/2019/01/14/python-array-module/","excerpt":"","text":"数组array 模块可以表示整数、浮点数、字符的数组。 初始化array(typecode,__initializer=…)typecode表示数组的类型,文章末尾有一个参数表包含所有支持类型以及内存占用情况initializer为初始化参数,是一个list、或者iterable、或是 bytes-like object1234567import array\"\"\"array_name = array.array(typecode, [initializers])\"\"\"arr=array.array('i',[1,2,3,4,5])# orarr1=array.array('i',[x for x in range(10)]) 支持的操作(官方文档)Array objects support the ordinary sequence operations of indexing(索引), slicing(切片), concatenation(拼接), and multiplication(乘法). 函数array.typecode（数据类型）The typecode character used to create the array.用于创建数组的typecode字符。 array.itemsize（单个数组元素大小）The length in bytes of(以字节为单位) one array item(数据项) in the internal(内部) representation(表示). 123456arr1 = array.array('i',[0,1,1,2,3])arr2 = array.array('i',[0,1,2,3])arr1.itemsize # 4arr2.itemsize # 4arr1.typecode # 'i'#相同的不占多余的空间 array.append(x)（添加元素）Append a new item(项) with value x to the end of the array. array.buffer_info() （返回一个元组：(存储数组的地址,元素的数量)）Return a tuple (address, length) giving the current(当前的) memory address(内存地址) and the length in elements of(在…的元素中) the buffer(缓冲区) used to hold array’s contents(内容). The size of the memory buffer(内存缓冲区) in bytes(以字节为单位) can be computed as(计算为) array.buffer_info()[1] * array.itemsize. This is occasionally(偶尔) useful when working with low-level (and inherently(本质上) unsafe) I/O interfaces(接口) that require memory addresses, such as certain(某些) ioctl() operations. The returned numbers are valid(有效) as long as(只要) the array exists and no length-changing(长度改变) operations are applied to it. Note When using array objects from code written in C or C++ (the only way to effectively(有效) make use of(有效利用) this information), it makes more sense(意义) to use the buffer interface supported by array objects. This method is maintained for backward compatibility(保持向后兼容) and should be avoided in new code. The buffer interface is documented in Buffer Protocol(缓冲区协议). 这个函数是为了保持向后兼容的，所以就不写解释了，翻译纯属为了熟悉英语。之后简单的，一看就懂的，或者基本用不上的，就只翻译了，或者看心情。 array.byteswap() “Byteswap” all items(项) of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised(引发). It is useful when reading data from a file written on a machine with a different byte order不同的字节序列. array.count(x)（统计个数） Return the number of occurrences of x(x发生的次数) in the array. array.extend(iterable)（扩展另一个array） Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array. 12345678arr1 = array.array('i',[i for i in range(10) if i%2==1]) #array('i', [1, 3, 5, 7, 9])arr2 = array.array('i',[i for i in range(10) if i%2==0]) #array('i', [0, 2, 4, 6, 8])#扩展相同type code的array对象arr1.extend(arr2)print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8])#扩展可迭代对象arr1.extend([i for i in range(100,110) if i%2==0])print(arr1) # array('i', [1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 100, 102, 104, 106, 108]) array.fromlist(list)123456arr2 = array.array('i',[0,99])l=[i for i in range(1000)]arr2.fromlist(l) #与下面for循环等价for i in l: #与上面fromlist等价 arr2.append(i) Append items from the list. This is equivalent to(相当于) for x in list: a.append(x) except that if there is a type error, the array is unchanged. array.index(x)（返回元素所在位置） Return the smallest i such that i is the index of the first occurrence of(出现) x in the array. array.insert(i, x) （将元素x插入到i前面） Insert a new item with value x in the array before position i. Negative(负) values are treated as(被视为) being relative(相对) to the end of the array. array.pop([i])（删除并返回一个元素） Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.默认是最后一个值 array.remove(x)（删除第一次出现的x） Remove the first occurrence of x from the array. array.reverse()（逆序） Reverse the order of the items in the array. array.tolist()（转换成list列表） Convert the array to an ordinary list with the same items. 操作元素示例12345678910import arrayarr1 = array.array('i',[i for i in range(10) if i%2==1])arr2 = array.array('i',[2,4,6,8,2])arr1.extend(arr2) #扩展print(arr1[0]) #第一个元素arr1[1]=5 #改变元素arr1.insert(1,60) #插入第二个位置print(arr2.index(6)) #6的位置 为2arr2.remove(2) #删除所有的2print(arr2) # array('i', [4, 6, 8]) type code 定义 Type code C Type Python Type Minimum size in bytes Notes ‘b’ signed char int 1 ‘B’ unsigned char int 1 ‘u’ Py_UNICODE Unicode character 2 (1) ‘h’ signed short int 2 ‘H’ unsigned short int 2 ‘i’ signed int int 2 ‘I’ unsigned int int 2 ‘l’ signed long int 4 ‘L’ unsigned long int 4 ‘q’ signed long long int 8 (2) ‘Q’ unsigned long long int 8 (2) ‘f’ float float 4 ‘d’ double float 8 (1)Py_UNICODE是typedef wchar_t，是16位或32位，取决于平台，已经被移除，官网不推荐使用。 (2).(官网原话)The ‘q’ and ‘Q’ type codes are available only if the platform C compiler used to build Python supports C long long, or, on Windows, __int64.只有当用于构建Python的平台C编译器支持C long long，或者在Windows上支持int64时，’q’和’Q’类型代码才可用。__","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.ojbkfeng.com/categories/Python/"},{"name":"数据结构","slug":"Python/数据结构","permalink":"https://blog.ojbkfeng.com/categories/Python/数据结构/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://blog.ojbkfeng.com/tags/基础/"},{"name":"数组","slug":"数组","permalink":"https://blog.ojbkfeng.com/tags/数组/"}]}]}